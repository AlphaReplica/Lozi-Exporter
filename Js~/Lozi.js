/**
 * Created by Beka Mujirishvili
 * 
 * loads, parses and creates objects according to type
 */

var Lozi =
{
	Utils:
	{
		eulerAngles:function(object,x,y,z)
		{
			if(object)
			{
				x = (x) ? x : Lozi.Math.degrees(object.rotation.x);
				y = (y) ? y : Lozi.Math.degrees(object.rotation.y);
				z = (z) ? z : Lozi.Math.degrees(object.rotation.z);
				
				object.rotation.set(Lozi.Math.radians(x),Lozi.Math.radians(y),Lozi.Math.radians(z));
				
				return {x:Lozi.Math.degrees(object.rotation.x),y:Lozi.Math.degrees(object.rotation.y),z:Lozi.Math.degrees(object.rotation.z)};
			}
			return {x:0,y:0,z:0};
		},
		
		getMousePosition:function(e,element)
		{
			var x     = (e.clientX + document.body.scrollLeft + element.scrollLeft)-element.offsetLeft; 
			var y     = (e.clientY + document.body.scrollTop  + element.scrollTop )-element.offsetTop; 
		
			return {x:( (x / element.clientWidth ) * 2 - 1),
					y:(-(y / element.clientHeight) * 2 + 1)};
		},
			
		getObjectByProperty:function(objects,prop,val)
		{
			if(objects && objects.length>0)
			{
				for(var num = 0; num < objects.length; num++)
				{
					if(objects[num][prop] && objects[num][prop] == val)
					{
						return objects[num];
					}
				}
			}
			return null;
		},
		
		clearArray:function(arr,func,clearLevel,exclude)
		{
			if(arr)
			{
				while(arr.length>0)
				{
					if(clearLevel>0)
					{
						this.clearObject(arr[arr.length-1],func,clearLevel-1,exclude);
					}
					arr[arr.length-1] = null;
					arr.pop();
				}
			}
		},
			
		clearObject:function(obj,func,clearLevel,exclude)
		{
			if(obj)
			{
				if(func)
				{
					func(obj);
				}
				for(var key in obj)
				{
					if(clearLevel>0)
					{
						if(key && key!=null && obj[key] && obj[key]!=null)
						{
							if(obj[key].constructor === Object)
							{
								this.clearObject(obj[key],func,clearLevel-1);
							}
						}
						if(key && key!=null && obj[key] && obj[key]!=null)
						{
							if(obj[key].constructor === Array)
							{
								this.clearArray(obj[key],func,clearLevel-1);
							}
						}
					}
					var canDelete = true;
					if(exclude && exclude.length>0)
					{
						for(var num = 0; num < exclude.length; num++)
						{
							if(exclude[num] == key)
							{
								canDelete = false;
							}
						}
					}
					if(canDelete == true)
					{
						obj[key] = null;
					}
				}
			}
		},
			
		getPropertyArray:function(arr,property,remove)
		{
			var newArr = []
			if(arr && arr.length>0)
			{
				for(var num = 0; num < arr.length; num++)
				{
					if(arr[num][property])
					{
						newArr.push(arr[num][property]);
						if(remove == true)
						{
							arr[num][property] = null;
						}
					}
				}
			}
			return newArr;
		}
	},
	
	// Libraries Object is for parsing for specific WebGL engine, currently it supports only three.js
	Libraries:
	{
		Three:
		{	
			// Geometry Generated by imported data
			Geometry:
			{	
				generateGeometry:function(nameData,vertices,normals,uvs,faces)
				{
					var geometry = 
					{
						name	: "",
						vertices: [],
						normals : [],
						uvs     : []
					};
					
					for(var num1 = 0; num1 < faces.length; num1++ )
					{
						for(var num2 = 0; num2 < faces[num1].length; num2++ )
						{
							var index  = parseInt(faces[num1][num2]);
							var vertex = ((index>=0)?index-1:index+vertices.length/3)*3;
							var normal = ((index>=0)?index-1:index+normals.length/3)*3;
							
							geometry.vertices.push(vertices[vertex],vertices[vertex+1],vertices[vertex+2]);
							geometry.normals .push(normals [normal],normals [normal+1],normals [normal+2]);
						}
					}
					
					for(var num1 = 0; num1 < uvs.length; num1++ )
					{
						geometry.uvs.push([]);
						for(var num2 = 0; num2 < faces.length; num2++ )
						{
							for(var num3 = 0; num3 < faces[num2].length; num3++ )
							{
								var index  = parseInt(faces[num2][num3]);
								var uv     = ((index>=0)?index-1:index+uvs[num1].length/2)*2;
								geometry.uvs[num1].push(uvs[num1][uv],uvs[num1][uv+1]);
							}
						}
					}
					geometry.name = nameData;
					
					return geometry;
				},
				
				generateSkinData:function(geometry,geomData)
				{
					var influencesPerVertex = 4;
					var weights = [];
					var indices = [];
					
					for(var num1 = 0; num1 < geomData.geometry.faces.length; num1++ )
					{
						for(var num2 = 0; num2 < geomData.geometry.faces[num1].length; num2++ )
						{
							var index  = parseInt(geomData.geometry.faces[num1][num2]);
							var weight = ((index>=0)?index-1:index+geomData.skin.skinWeights.length/4)*4;
							var indice = ((index>=0)?index-1:index+indices.length/4)*4;

							weights.push(geomData.skin.skinWeights[weight],geomData.skin.skinWeights[weight+1],geomData.skin.skinWeights[weight+2],geomData.skin.skinWeights[weight+3]);
							indices.push(geomData.skin.skinIndices[indice],geomData.skin.skinIndices[indice+1],geomData.skin.skinIndices[indice+2],geomData.skin.skinIndices[indice+3]);
						}
					}
					
					if (weights && weights.length>0)
					{
						for ( var i = 0, l = weights.length; i < l; i += influencesPerVertex )
						{
							var x =                               	 weights[ i ];
							var y = (weights[ i + 1 ]!==undefined) ? weights[ i + 1 ] : 0;
							var z = (weights[ i + 2 ]!==undefined) ? weights[ i + 2 ] : 0;
							var w = (weights[ i + 3 ]!==undefined) ? weights[ i + 3 ] : 0;

							geometry.skinWeights.push(new THREE.Vector4( x, y, z, w ) );
						}
					}

					if (indices && indices.length>0)
					{
						for ( var i = 0, l = indices.length; i < l; i += influencesPerVertex )
						{
							var a =                               indices[ i ];
							var b = ( influencesPerVertex > 1 ) ? indices[ i + 1 ] : 0;
							var c = ( influencesPerVertex > 2 ) ? indices[ i + 2 ] : 0;
							var d = ( influencesPerVertex > 3 ) ? indices[ i + 3 ] : 0;

							geometry.skinIndices.push(new THREE.Vector4( a, b, c, d ) );
						}
					}
					geometry.bones = geomData.skin.bones;
					return geometry;
				},
			
				generateBlendShapeData:function(geometry,geomzData)
				{
					var morphData = geomzData.morph.blendShapes;
					
					for (var num1 = 0; num1 < morphData.length; num1++)
					{
						geometry.morphTargets[num1]			 = {};
						geometry.morphTargets[num1].name     = morphData[num1].name;
						geometry.morphTargets[num1].vertices = [];
							
						var blendShape   = morphData[num1];
						var geometryData = this.generateGeometry(blendShape.name,blendShape.vertices,geomzData.geometry.normals,geomzData.geometry.uv,geomzData.geometry.faces);
							
						for(var num2 = 0; num2 < geometryData.vertices.length; num2 += 3 )
						{
							var vertex = new THREE.Vector3(geometryData.vertices[num2],geometryData.vertices[num2+1],geometryData.vertices[num2+2]);

							geometry.morphTargets[num1].vertices.push(vertex);
						}
					}
					return geometry;
				},
				
				generateMeshGeometry:function(objInfo)
				{
					var geometry;
					if(objInfo.geometry)
					{
						var geometryData = this.generateGeometry(objInfo.name,
																 objInfo.geometry.vertices,
																 objInfo.geometry.normals,
																 objInfo.geometry.uv,
																 objInfo.geometry.faces);
														
						geometry = new THREE.BufferGeometry();
						geometry.addAttribute('position',new THREE.BufferAttribute(new Float32Array(geometryData.vertices),3));
						
						if(geometryData.normals.length>0){geometry.addAttribute('normal',new THREE.BufferAttribute(new Float32Array(geometryData.normals),3));}
						
						if(geometryData.uvs.length    >0)
						{
							for(var num = 0; num < geometryData.uvs.length; num++)
							{
								var numbr = (num>0) ? num+1 : "";
								geometry.addAttribute('uv'+numbr,new THREE.BufferAttribute(new Float32Array(geometryData.uvs[num]),2));
							}
						}
						
						var count = 0;
						for(var num = 0; num < objInfo.geometry.faces.length; num++ )
						{
							geometry.addGroup(count,objInfo.geometry.faces[num].length,num);
							count += objInfo.geometry.faces[num].length;
						}
					}
					
					geometry.hasSkin  = false;
					geometry.hasMorph = false;
					if(objInfo.skin || objInfo.morph)
					{
						geometry = new THREE.Geometry().fromBufferGeometry(geometry);
						
						if(objInfo.skin)
						{
							geometry.hasSkin = true;
							geometry = this.generateSkinData(geometry,objInfo);
						}
						if(objInfo.morph)
						{
							geometry.hasMorph = true;
							geometry = this.generateBlendShapeData(geometry,objInfo);
						}
					}
					if(objInfo.id)
					{
						geometry.meshID = objInfo.id;
					}
					
					if(objInfo.geometry.castShadows)
					{
						geometry.castShadow = objInfo.geometry.castShadows;
					}
					if(objInfo.geometry.recieveShadows)
					{
						geometry.receiveShadow = objInfo.geometry.recieveShadows;
					}
					return geometry;
				},
				
				createMeshByGeometryID:function(id,materialIDs,data)
				{
					var mesh;
					var material;
					var materials = [];
					var geometry = Lozi.Utils.getObjectByProperty(data.geometries,"meshID",id);
					
					if(materialIDs)
					{
						for(var num = 0; num < materialIDs.length; num++)
						{
							var mat = Lozi.Utils.getObjectByProperty(data.materials,"matId",materialIDs[num]);
							if(mat)
							{
								materials.push(mat);
							}
						}
						material = (materials.length>1) ? new THREE.MultiMaterial(materials) : materials[0];
					}
					
					
					if(geometry)
					{
						if(geometry.hasMorph==false && geometry.hasSkin==false)
						{
							mesh = new THREE.Mesh(geometry,material);
						}
						else
						{
							mesh = new THREE.SkinnedMesh(geometry,material);
							
							for(var num = 0; num < materials.length; num++)
							{
								materials[num].skinning 	= geometry.hasSkin;
								materials[num].morphTargets = geometry.hasMorph;
							}
							
						}
						if(geometry.receiveShadow)
						{
							mesh.receiveShadow = geometry.receiveShadow;
						}
						if(geometry.castShadow)
						{
							mesh.castShadow    = geometry.castShadow;
						}
					}
					return mesh;
				},
				
				combineMeshes:function(obj)
				{
					var merged   = [];
					var buffered = [];
					var meshCont = new THREE.Object3D();
					for(var num = 0; num < obj.objects().length; num++)
					{
						obj.objects()[num].updateMatrixWorld(true);
					}
						
					for(var num1 = 0; num1 < obj.materials().length; num1++)
					{
						var meshFaceMaterial = new THREE.MeshFaceMaterial([obj.materials()[num1]]);
						
						var mergeGeometry = new THREE.Geometry();
						
						for(var num2 = 0; num2 < obj.meshes().length; num2++)
						{
							if(obj.meshes()[num2].material == obj.materials()[num1])
							{
								var matrix = obj.meshes()[num2].matrixWorld;
								var geom   = obj.meshes()[num2].geometry;
								
								if(geom.attributes)
								{
									geom = new THREE.Geometry().fromBufferGeometry(geom);
									buffered.push(geom);
								}
								mergeGeometry.merge(geom,matrix);
							}
						 }
						 var mergedMesh  = new THREE.Mesh(mergeGeometry, meshFaceMaterial);
						 mergedMesh.name = "Combined-"+obj.materials()[num1].name;
						 merged.push(mergedMesh);
						 meshCont.add( mergedMesh );
					}
					Lozi.Utils.clearArray(buffered,Lozi.Static.Geometry.disposeGeometry,1);
					Lozi.Utils.clearArray(obj.meshes(),Lozi.Static.Geometry.disposeMesh,1,['remove','children']);
					
					meshCont.name = "Combined-Meshes";
					obj.add(meshCont);
					
					return merged;
				},
	
				disposeMesh:function(obj)
				{
					if(obj.parent)
					{
						obj.parent.remove(obj);
					}
				},
				
				disposeGeometry:function(obj)
				{
					if(obj.dispose && obj.constructor === Function)
					{
						obj.dispose();
					}
					if(obj.removeAttribute)
					{
						obj.removeAttribute("position");
						obj.removeAttribute("normal");
						obj.removeAttribute("uv");
						obj.removeAttribute("uv2");
					}
				}
			},
			
			Material:
			{	
				generateMaterial:function(matData,data)
				{
					var material;
					
					switch(matData.type)
					{
						case 0:{material = new THREE.MeshStandardMaterial(); break;}
						case 1:{material = new THREE.MeshBasicMaterial   (); break;}
						case 2:{material = new THREE.MeshPhongMaterial   (); break;}
						case 3:{material = new THREE.MeshLambertMaterial (); break;}
					}
					if(material)
					{
						material.matId 		  = matData.id;
						material.name  		  = matData.name;
						material.materialSide = matData.side;
						
						material.side = (material.materialSide == 0) ? THREE.FrontSide  : 
										(material.materialSide == 1) ? THREE.BackSide   : 
										(material.materialSide == 2) ? THREE.DoubleSide :  THREE.FrontSide;
										
						if(matData.properties)
						{
							if(matData.type!=1)
							{
								if(matData.properties._EmissionMap)
								{
									material.emissiveMap = Lozi.Utils.getObjectByProperty(data.generatedAssets.textures,'texID',matData.properties._EmissionMap);
								}
								if(matData.properties._EmissionColor)
								{
									material.emissive = new THREE.Color(matData.properties._EmissionColor[0],matData.properties._EmissionColor[1],matData.properties._EmissionColor[2]);
								}
								if(matData.properties._BumpMap && matData.type!=3)
								{
									material.bumpMap      = Lozi.Utils.getObjectByProperty(data.generatedAssets.textures,'texID',matData.properties._BumpMap);
									material.bumpMapScale = 1;
								}
								if(matData.properties._Illum)
								{
									material.emissiveMap = Lozi.Utils.getObjectByProperty(data.generatedAssets.textures,'texID',matData.properties._Illum);
									material.emissive = new THREE.Color(1,1,1);
								}
							}
							
							if(matData.properties._Cube)
							{
								material.envMap = Lozi.Utils.getObjectByProperty(data.generatedAssets.textures,'texID',matData.properties._Cube);
								material.metalness = 1;
							}
							if(matData.properties._ReflectColor)
							{
								material.envMapIntensity = matData.properties._ReflectColor[3];
							}
							if(matData.properties._Color)
							{
								material.color = new THREE.Color(matData.properties._Color[0],matData.properties._Color[1],matData.properties._Color[2]);
							}
							if(matData.properties._Metallic)
							{
								material.metalness = matData.properties._Metallic;
							}
							if(matData.properties._MainTex)
							{
								material.map      = Lozi.Utils.getObjectByProperty(data.generatedAssets.textures,'texID',matData.properties._MainTex);
							}
							if(matData.properties.transparentMap)
							{
								material.transparent = true;
								material.alphaMap = Lozi.Utils.getObjectByProperty(data.generatedAssets.textures,'texID',matData.properties.transparentMap);
							}
							if(matData.properties.specularMap)
							{
								material.specular = Lozi.Utils.getObjectByProperty(data.generatedAssets.textures,'texID',matData.properties.specularMap);
							}
							if(matData.properties._BumpScale)
							{
								material.bumpMapScale = matData.properties._BumpScale;
							}
							if(matData.properties.lightMap)
							{
								material.lightMap = Lozi.Utils.getObjectByProperty(data.generatedAssets.textures,'texID',matData.properties.lightMap);
							}
						}
						return material;
					}
				},
				
				disposeMaterial:function(obj)
				{
					if(obj.dispose && obj.constructor === Function)
					{
						obj.dispose();
					}
				}
			},
			
			Texture:
			{
				generateTexture:function(dataObj)
				{
					if(dataObj && dataObj.textureData && dataObj.textureData.length>0)
					{
						if(dataObj.textureData[0])
						{
							var image     	     = dataObj.textureData[0];
							var texture   	     = new THREE.Texture();
							texture.texID	     = dataObj.id;
							texture.name  	     = dataObj.name;
							texture.image 	     = image;
							texture.usedImages   = [texture.image];
							texture.needsUpdate  = true;
							return texture;
						}
					}
				},
				
				generateCubeTexture:function(dataObj)
				{
					if(dataObj && dataObj.textureData && dataObj.textureData.length>0)
					{
						var texture    	    = new THREE.CubeTexture();
						texture.texID  	    = dataObj.id;
						texture.name   	    = dataObj.name;
						texture.images 	    = [];
						texture.usedImages  = texture.images;
						texture.needsUpdate = true;
						
						for(var num = 0; num < dataObj.textureData.length; num++)
						{
							texture.images.push(dataObj.textureData[num]);
						}
						return texture;
					}
				},
				
				disposeTexture:function(obj)
				{
					if(obj.dispose && obj.constructor === Function)
					{
						obj.dispose();
					}
				},
				
				disposeImage:function(obj)
				{
					if(obj.src)
					{
						obj.src = "";
					}
				}
			},
			
			Animation:
			{
				generateSkinAnimationClip:function(clip,objects)
				{
					if(clip && objects)
					{
						if(objects && objects.length>0)
						{
							if(clip.hierarchy)
							{
								var nodes = [];
								for ( var num = 0; num < objects.length; num++ )
								{
									nodes.push({});
								}
								
								for ( var num1 = 0; num1 < clip.hierarchy.length; num1++ )
								{
									var hier = clip.hierarchy[num1];
									if(hier.keys)
									{
										for ( var num2 = 0; num2 < hier.keys.length; num2++ )
										{
											hier.keys[num2] = hier.keys[num2];
										}
									}
									nodes[clip.hierarchy[num1].index] = hier;
								}
							}
							clip.hierarchy = nodes;
							
							return THREE.AnimationClip.parseAnimation(clip,objects);
						}
					}
				},
				
				setAnimation:function(obj,anim)
				{
					var mixer = new THREE.AnimationMixer(obj);
					
					if(anim.clips && anim.clips.length>0)
					{
						mixer.clips = {};
						for(var num = 0; num < anim.clips.length; num++)
						{
							if(anim.clips[num])
							{
								mixer.clips[anim.clips[num].name]		   = mixer.clipAction(anim.clips[num], obj);
								mixer.clips[anim.clips[num].name].id 	   = anim.clips[num].id;
								mixer.clips[anim.clips[num].name].name 	   = anim.clips[num].name;
								mixer.clips[anim.clips[num].name].mode 	   = anim.clips[num].mode;
								mixer.clips[anim.clips[num].name].duration = anim.clips[num].duration;
								mixer.clips[anim.clips[num].name].setEffectiveWeight(1);
							}
						}
					}
					return mixer;
				},
				
				loopMode:function(type)
				{
					if(type == "Once")
					{
						return THREE.LoopOnce;
					}
					if(type == "PingPong")
					{
						return THREE.LoopPingPong
					}
					return THREE.LoopRepeat;
				},
				
				disposeAnimation:function(obj)
				{
					if(obj.stopAllAction){obj.stopAllAction();}
					if(obj.uncacheRoot && obj.getRoot){obj.uncacheRoot(obj.getRoot());}
					if(obj.clips)
					{
						for(var key in obj.clips)
						{
							obj.clips[key].stop();
							obj.uncacheClip(obj.clips[key].getClip());
							obj.uncacheAction(obj.clips[key]);
							obj.clips[key] = null;
						}
					}
				}
			},
			
			Light:
			{
				setLightData:function(targetLight,data)
				{
					targetLight.color 	   = new THREE.Color(data.color[0],data.color[1],data.color[2]);
					targetLight.intensity  = data.intensity;
					targetLight.distance   = data.range * 100;
					targetLight.angle      = Lozi.Math.radians(data.angle);
					targetLight.castShadow = data.shadow;
					targetLight.lightID    = data.lightID;
				}
			},
			
			Camera:
			{
				setCameraData:function(targetCamera,data)
				{
					targetCamera.cameraID = data.cameraID;
					targetCamera.fov      = -data.fov;
					targetCamera.near     = data.near;
					targetCamera.far      = data.far;
					targetCamera.left     = data.orthoSize;
					targetCamera.right    = data.orthoSize;
					targetCamera.top      = data.orthoSize;
					targetCamera.bottom   = data.orthoSize;
					targetCamera.updateProjectionMatrix();
				}
			},
			
			Sound:
			{
				createListener:function(obj)
				{
					var listener = new THREE.AudioListener();
					if(obj)
					{
						obj.add(listener);
					}
					return listener;
				},
				
				createSource:function(listener,data,sound,obj)
				{
					var source = new THREE.PositionalAudio(listener);
					
					source.setBuffer(sound.dataBuffer);
					source.setRefDistance(data.spread);
					source.source.loop = data.loop;
					source.sourceID    = data.id;
					source.setVolume((data.mute == true) ? 0 : 1);
					
					if(data.autoPlay == true)
					{
						source.play();
					}
					
					obj.sound = source;
					obj.add(obj.sound);
					
					return source;
				},
				
				disposeSoundSource:function(obj)
				{
					if(obj.isPlaying == true)
					{
						obj.stop();
					}
					if(obj.parent)
					{
						obj.parent.remove(obj);
					}
				},
				
				disposeSoundListener:function(obj)
				{
					if(obj.parent)
					{
						obj.parent.remove(obj);
					}
				}
			},
			
			Object:
			{
				// Copies Render object render function to add currentCamera property, required for events
				updateObjectRenderer:function(obj)
				{
					if(obj && obj.render)
					{
						if(!obj.baseRender)
						{
							obj.baseRender = obj.render;
							
							obj.raycaster  = new THREE.Raycaster();
							
							obj.render = function(a,b,c,d)
							{
								this.currentCamera = b;
								this.baseRender(a,b,c,d);
							};
						}
					}
					return obj;
				},
				
				// Object created by given type
				classByType:function(enm)
				{
					switch(enm)
					{
						case Lozi.Static.Object.types.Mesh				 :{type = THREE.Mesh; 		  	    break;}
						case Lozi.Static.Object.types.SkinnedMesh		 :{type = THREE.SkinnedMesh; 		break;}
						//case Lozi.Static.Object.types.OrthographicCamera:{type = THREE.OrthographicCamera; break;}
						case Lozi.Static.Object.types.OrthographicCamera :{type = THREE.PerspectiveCamera;  break;}
						case Lozi.Static.Object.types.PerspectiveCamera  :{type = THREE.PerspectiveCamera;  break;}
						case Lozi.Static.Object.types.AreaLight		 	 :{type = THREE.AmbientLight;    	break;}
						case Lozi.Static.Object.types.PointLight		 :{type = THREE.PointLight;    	    break;}
						case Lozi.Static.Object.types.DirectionalLight   :{type = THREE.DirectionalLight;   break;}
						case Lozi.Static.Object.types.SpotLight		 	 :{type = THREE.SpotLight;    	    break;}
						case Lozi.Static.Object.types.Object			 :
						case Lozi.Static.Object.types.AnimationObject	 :
						case Lozi.Static.Object.types.Object3D			 :{type = THREE.Object3D;    		break;}
						case Lozi.Static.Object.types.Scene			 	 :{type = THREE.Scene;    	  	    break;}
					}
					
					type.prototype.onAdded = type.prototype.traverse;
					
					
					return type;
				},
				
				onInteract:function(e,objects,rend,callback)
				{
					var mouse = Lozi.Utils.getMousePosition(e,rend.domElement);
					
					if(rend && rend.raycaster && rend.currentCamera)
					{
						rend.raycaster.setFromCamera(mouse,rend.currentCamera);
					
						var intersects = rend.raycaster.intersectObjects(objects);
						
						if (intersects.length > 0 && callback)
						{
							callback(intersects[0]);
						}
					}
				},
				
				disposeObject:function(obj)
				{
					if(obj.parent)
					{
						obj.parent.remove(obj);
					}
				}
			},
		},
		
		object:function()
		{
			if(typeof THREE != "undefined")
			{
				return Lozi.Libraries.Three;
			}
			throw new Error("NO WEBGL LIBRARY INCLUDED!");
		},
	},
	
	Static:
	{
		Geometry:
		{
			generateMeshGeometry:function(objInfo,bones)
			{
				if(bones)
				{
					if(objInfo.skin)
					{
						if(objInfo.skin.bones)
						{
							objInfo.skin.bones = this.getMeshBoneAssets(objInfo.skin.bones,bones);
						}
					}		
				}
				
				return Lozi.Libraries.object().Geometry.generateMeshGeometry(objInfo);
			},
			
			parseGeometries:function(meshes,bones)
			{
				var geometries = [];
				if(meshes)
				{
					for(var num = 0; num < meshes.length; num++)
					{
						if(meshes[num])
						{
							geometries.push(this.generateMeshGeometry(meshes[num],bones));
						}
					}
				}
				return geometries;
			},
			
			getMeshBoneAssets:function(id,bones)
			{
				for(var num = 0; num < bones.length; num++)
				{
					if(bones[num].id == id)
					{
						return bones[num].bones;
					}
				}
				return id;
			},
			
			combineMeshes:function(obj)
			{
				return Lozi.Libraries.object().Geometry.combineMeshes(obj);
			},
			
			createMeshByGeometryID:function(id,materials,data)
			{
				return Lozi.Libraries.object().Geometry.createMeshByGeometryID(id,materials,data);
			},
			
			disposeMesh:function(obj)
			{
				Lozi.Libraries.object().Geometry.disposeMesh(obj);
			},
				
			disposeGeometry:function(obj)
			{
				Lozi.Libraries.object().Geometry.disposeGeometry(obj);
			}
		},
		
		Material:
		{
			generateMaterial:function(matData,textures)
			{
				return Lozi.Libraries.object().Material.generateMaterial(matData,textures);
			},
			
			generateMaterials:function(materialData,data)
			{
				var materials = [];
				for(var num = 0; num < materialData.length; num++)
				{
					var material = this.generateMaterial(materialData[num],data);
					if(material)
					{
						materials.push(material);
					}
				}
				return materials;
			},
			
			cloneMaterials:function(materials)
			{
				var arr = [];
				
				if(materials)
				{
					for(var num = 0; num < materials.length; num++)
					{
						var material   = materials[num].clone();
						material.matId = materials[num].matId;
						material.side  = materials[num].side;
						arr.push(material);
					}
				}
				return arr;
			},
			
			disposeMaterial:function(obj)
			{
				Lozi.Libraries.object().Material.disposeMaterial(obj);
			}
		},
		
		Texture:
		{
			loadImage:function(imageData,complete,progress,error)
			{
				Image.prototype.loadImage = function(url,complete,progress,error)
				{
					var img = this;
					img.onload = function(e)
					{
						var target = (!e.path) ? e.target : e.path[0];
							
						target.loaded = true;
						if(complete)
						{
							complete();
						}
					};
						
					if(url.indexOf("data:image/png;base64,")>-1)
					{
						img.src 		 = url;
						img.loadProgress = 1;
						
						if(progress)
						{
							progress(img.loadProgress);
						}
					}
					else
					{
						var request = new XMLHttpRequest();
					
						request.onload = function()
						{
							var blob = new Blob( [ this.response ]);
							img.src  = window.URL.createObjectURL( blob );
						}
							
						request.onprogress = function(e)
						{
							img.loadProgress = (e.loaded / e.total);
							if(progress)
							{
								progress(img.loadProgress);
							}
						}
						
						request.onerror = error;
					
						request.open('GET', url , true );
						request.responseType = 'arraybuffer';
						request.send();
					}
				}
				
				var image = new Image();
				image.loadImage(imageData,complete,progress,error);
				
				return image;
			},
			
			loadImages:function(imagesData,complete,progress,error)
			{
				var images = [];
				
				for(var num1 = 0; num1 < imagesData.length; num1++)
				{
					for(var num2 = 0; num2 < imagesData[num1].textureData.length; num2++)
					{
						var image = this.loadImage(imagesData[num1].textureData[num2],complete,progress,error);
						imagesData[num1].textureData[num2] = image;
						
						images.push(image);
					}
				}
				
				return images;
			},
			
			loadTexture:function(texData)
			{
				if(texData && texData.textureData && texData.textureData.length>0)
				{
					var texture;
					switch(texData.textureData.length)
					{
						case 1:{texture = Lozi.Libraries.object().Texture.generateTexture	  (texData); break;}
						case 6:{texture = Lozi.Libraries.object().Texture.generateCubeTexture(texData); break;}
					}
					return texture;
				}
			},
			
			loadTextures:function(texturesData)
			{
				var textures = [];
				for(var num = 0; num < texturesData.length; num++)
				{
					var texture = this.loadTexture(texturesData[num]);
					if(texture)
					{
						textures.push(texture);
					}
				}
				return textures;
			},
			
			getTextureImages:function(textures,complete)
			{
				var images = [];
				for(var num1 = 0; num1 < textures.length; num1++)
				{
					for(var num2 = 0; num2 < textures[num1].usedImages.length; num2++)
					{
						textures[num1].usedImages[num2].onload = function(e)
						{
							var target = (!e.path) ? e.target : e.path[0];
						
							target.loaded = true;
							if(complete)
							{
								complete();
							}
						};
						images.push(textures[num1].usedImages[num2]);
					}
				}
				return images;
			},
			
			disposeTexture:function(obj)
			{
				Lozi.Libraries.object().Texture.disposeTexture(obj);
			}
		},
		
		Sound:
		{	
			loadSound:function(soundData,complete,progress,error)
			{
				var obj  = {};
				obj.id   = soundData.id;
				obj.name = soundData.name;
				
				var request = new XMLHttpRequest();
				
				request.open('GET', soundData.data, true);
				request.responseType = 'arraybuffer';
				request.onload		 = function()
				{
					window.AudioContext = window.AudioContext || window.webkitAudioContext;
							
					var context = new AudioContext();
							
					context.decodeAudioData(request.response, function(buffer)
					{
						obj.dataBuffer = buffer;
						obj.loaded     = true;
						if(complete)
						{
							complete();
						}
					},
					function(e)
					{
						console.error("Couldn't decode audio!");
					});
				}
				request.onprogress = function(e)
				{
					obj.loadProgress = (e.loaded / e.total);
					if(progress)
					{
						progress(obj.loadProgress);
					}
				}
				request.onerror = error;
				request.send();
				
				return obj;
			},
			
			loadSounds:function(soundsData,complete,progress,error)
			{
				var sounds = [];
				
				for(var num = 0; num < soundsData.length; num++)
				{
					var sound = this.loadSound(soundsData[num],complete,progress,error);
					sounds.push(sound);
				}
				return sounds;
			},
			
			createListener:function(obj)
			{
				return Lozi.Libraries.object().Sound.createListener(obj);
			},
			
			setSounds:function(obj)
			{
				for(var num = 0; num < obj.soundSources().length; num++)
				{
					this.setSound(obj.soundSources()[num],obj);
				}
			},
			
			setSound:function(obj,scopeObj)
			{
				var soundData = obj.sound;
				var listener  = (scopeObj.soundListeners().length>0) ? scopeObj.soundListeners()[0] : scopeObj.createSoundListener();
				var clip 	  = Lozi.Utils.getObjectByProperty(scopeObj.data().generatedAssets.sounds,'id',soundData.clip);
				
				if(clip)
				{
					Lozi.Libraries.object().Sound.createSource(listener,soundData,clip,obj);
				}
			},
			
			disposeSoundSource:function(obj)
			{
				Lozi.Libraries.object().Sound.disposeSoundSource(obj);
			},
					
			disposeSoundListener:function(obj)
			{
				Lozi.Libraries.object().Sound.disposeSoundListener(obj);	
			}
		},
		
		Animation:
		{
			setAnimationData:function(obj,data)
			{
				var animations = [];
				if(data && obj)
				{
					var anim = Lozi.Utils.getObjectByProperty(data.generatedAssets.animations.skin,'id',obj.animationID);
					
					if(anim)
					{
						if(anim.clips && anim.clips.length>0)
						{
							var mixer = Lozi.Libraries.object().Animation.setAnimation(obj,anim);
							mixer.id  = anim.id;
							obj.mixer = mixer;
							animations.push(mixer);
						}
					}
				}
				return animations;
			},
			
			generateSkinAnimations:function(animations,data)
			{
				var generated = [];
				if(animations && animations.length>0 && data.objects)
				{
					var objects = Lozi.Static.Object.getHierarchyObjectsByProperty(data.objects,'animationID');
					
					for(var num1 = 0; num1 < objects.length; num1++)
					{
						if(objects[num1].meshID)
						{
							var geometry = Lozi.Utils.getObjectByProperty(data.assets.meshes,'id',objects[num1].meshID);
							
							if(geometry && geometry.skin && geometry.skin.bones)
							{
								for(var num2 = 0; num2 < animations.length; num2++)
								{
									if(objects[num1].animationID == animations[num2].id)
									{
										if(!Lozi.Utils.getObjectByProperty(generated,'id',animations[num2].id))
										{
											var animation   = {};
											animation.id    = animations[num2].id;
											animation.clips = [];
											generated.push(animation);
											
											if(animations[num2].clips)
											{
												for(var num3 = 0; num3 < animations[num2].clips.length; num3++)
												{
													if(!Lozi.Utils.getObjectByProperty(animation.clips,'id',animations[num2].clips[num3].id))
													{
														var clip  	  = this.generateSkinAnimationClip(animations[num2].clips[num3],geometry.skin.bones);
														clip.id   	  = animations[num2].clips[num3].id;
														clip.mode 	  = animations[num2].clips[num3].mode;
														clip.duration = animations[num2].clips[num3].length;
														animation.clips.push(clip);
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
				
				return generated;
			},
			
			generateSkinAnimationClip:function(clip,objects)
			{
				return Lozi.Libraries.object().Animation.generateSkinAnimationClip(clip,objects);
			},

			getGeneratedClips:function(animations)
			{
				var arr = [];
				if(animations)
				{
					for(var num = 0; num < animations.length; num++)
					{
						if(animations[num])
						{
							for(var key in animations[num].clips)
							{
								arr.push(animations[num].clips[key]);
							}
						}
					}
				}
				return arr;
			},
			
			loopMode:function(type)
			{
				return Lozi.Libraries.object().Animation.loopMode(type);
			},
			
			disposeAnimation:function(obj)
			{
				Lozi.Libraries.object().Animation.disposeAnimation(obj);
			}
		},
		
		Light:
		{
			setLightData:function(target,data)
			{
				Lozi.Libraries.object().Light.setLightData(target,data);
			}
		},
		
		Camera:
		{
			setCameraData:function(target,data)
			{
				Lozi.Libraries.object().Camera.setCameraData(target,data);
			}
		},
		
		ScriptProperties:
		{
			getTypeFromEnum:function(val)
			{
				var returnType = val;
				
				switch(val)
				{
					case  0 :{returnType = "Float"; 		  break;}
					case  1 :{returnType = "Int"; 			  break;}
					case  2 :{returnType = "Boolean"; 		  break;}
					case  3 :{returnType = "String"; 		  break;}
					case  4 :{returnType = "Rect"; 			  break;}
					case  5 :{returnType = "Vector2"; 		  break;}
					case  6 :{returnType = "Vector3"; 		  break;}
					case  7 :{returnType = "Vector4"; 		  break;}
					case  8 :{returnType = "Material";  	  break;}
					case  9 :{returnType = "Texture2D"; 	  break;}
					case 10 :{returnType = "Cubemap"; 		  break;}
					case 11 :{returnType = "Mesh";	 		  break;}
					case 12 :{returnType = "AudioClip"; 	  break;}
					case 13 :{returnType = "AudioSource";     break;}
					case 14 :{returnType = "Animation"; 	  break;}
					case 15 :{returnType = "AnimationClip";   break;}
					case 16 :{returnType = "Light";  		  break;}
					case 17 :{returnType = "Camera";   		  break;}
					case 18 :{returnType = "Collider";   	  break;}
					case 19 :{returnType = "Object"; 		  break;}
					
					case 20 :{returnType = "Float[]";  		  break;}
					case 21 :{returnType = "Int[]"; 		  break;}
					case 22 :{returnType = "Boolean[]"; 	  break;}
					case 23 :{returnType = "String[]";  	  break;}
					case 24 :{returnType = "Rect[]"; 		  break;}
					case 25 :{returnType = "Vector2[]"; 	  break;}
					case 26 :{returnType = "Vector3[]"; 	  break;}
					case 27 :{returnType = "Vector4[]"; 	  break;}
					case 28 :{returnType = "Material[]";	  break;}
					case 29 :{returnType = "Texture2D[]";	  break;}
					case 30 :{returnType = "Cubemap[]";	      break;}
					case 31 :{returnType = "Mesh[]"; 		  break;}
					case 32 :{returnType = "AudioClip[]";	  break;}
					case 33 :{returnType = "AudioSource[]";   break;}
					case 34 :{returnType = "Animation[]";	  break;}
					case 35 :{returnType = "AnimationClip[]"; break;}
					case 36 :{returnType = "Light[]";  		  break;}
					case 37 :{returnType = "Camera[]";   	  break;}
					case 38 :{returnType = "Collider[]";      break;}
					case 39 :{returnType = "Object[]"; 		  break;}
				}
				return returnType;
			},
			
			parseEnumsToTypes:function(properties)
			{
				if(properties)
				{
					for(var scriptProps in properties)
					{
						for(var props in properties[scriptProps])
						{
							properties[scriptProps][props].type = this.getTypeFromEnum(properties[scriptProps][props].type);
						}
					}
				}
				return properties;
			},
			
			bindPropertyToObject:function(type,property,arr,propertyName)
			{
				if(type && property && arr && propertyName)
				{
					if(property.type.indexOf(type)>-1)
					{
						if(property.type.indexOf("[]")>-1)
						{
							var newArr = [];
							for(var num = 0; num < property.value.length; num++)
							{
								var newVal = Lozi.Utils.getObjectByProperty(arr,propertyName,property.value[num]);
								
								newVal = (newVal) ? newVal : property.value[num];
								
								newArr.push(newVal);
							}
							property.value = newArr;
						}
						else
						{
							var newVal = Lozi.Utils.getObjectByProperty(arr,propertyName,property.value);
							if(newVal)
							{
								property.value = newVal;
							}
						}
					}
				}
				return property;
			},
			
			bindPropertiesToObjects:function(properties,obj)
			{
				if(properties && obj)
				{
					for(var scriptProps in properties)
					{
						for(var props in properties[scriptProps])
						{
							var property = properties[scriptProps][props];
							property = this.bindPropertyToObject("Material" 	,property,obj.data().generatedAssets.materials,"matId");
							property = this.bindPropertyToObject("Texture2D"	,property,obj.data().generatedAssets.textures ,"texID");
							property = this.bindPropertyToObject("Cubemap"  	,property,obj.data().generatedAssets.textures ,"texID");
							property = this.bindPropertyToObject("AudioClip"	,property,obj.data().generatedAssets.sounds ,"id");
							property = this.bindPropertyToObject("AnimationClip",property,Lozi.Static.Animation.getGeneratedClips(obj.animations()),"id");
							property = this.bindPropertyToObject("AudioSource"	,property,Lozi.Utils.getPropertyArray(obj.soundSources(),"sound"),"sourceID");
							property = this.bindPropertyToObject("Collider"		,property,obj.colliders(),"id");
							property = this.bindPropertyToObject("Mesh"     	,property,obj.meshes(),"meshGeometryID");
							property = this.bindPropertyToObject("Animation"	,property,obj.animations(),"id");
							property = this.bindPropertyToObject("Object"		,property,obj.objects(true),"loziID");
							property = this.bindPropertyToObject("Camera"		,property,obj.cameras(),"cameraID");
							property = this.bindPropertyToObject("Light"		,property,obj.lights(),"lightID");
							
							properties[scriptProps][props] = property;
						}
					}
				}
				return properties;
			},
			
			parseProperties:function(properties,obj)
			{
				properties = this.parseEnumsToTypes(properties);
				
				properties = this.bindPropertiesToObjects(properties,obj);
				return properties;
			},
			
			parseObjectProperties:function(obj)
			{
				if(obj)
				{
					if(obj.properties().length>0)
					{
						for(var num = 0; num < obj.properties().length; num++)
						{
							obj.properties()[num].properties = this.parseProperties(obj.properties()[num].properties,obj);
						}
					}
				}
			}
		},
		
		Colliders:
		{
			// Collider Types
			// 0 : BoxCollider
			// 1 : SphereCollider
			// 2 : CapsuleCollider
		},
		
		Object:
		{
			types:
			{
				None               : 0,
				Scene    		   : 1,
				Object3D 		   : 2,
				AnimationObject    : 3,
				Object			   : 4,
				Bone               : 5,
				SpotLight   	   : 6,
				DirectionalLight   : 7,
				PointLight 		   : 8,
				AreaLight 		   : 9,
				PerspectiveCamera  : 10,
				OrthographicCamera : 11,
				SkinnedMesh 	   : 12,
				Mesh 			   : 13
			},
			
			getHierarchyObjectsByProperty:function(object,prop,arr)
			{
				arr = (arr) ? arr : [];
				
				if(object)
				{
					if(object[prop] && arr.indexOf(object)<0)
					{
						arr.push(object);
					}
					if(object.children)
					{
						for(var num = 0; num < object.children.length; num++)
						{
							this.getHierarchyObjectsByProperty(object.children[num],prop,arr);
						}
					}
				}
				return arr;
			},
			
			getHierarchyObjectByID:function(object,id)
			{
				if(object)
				{
					if(object.id == id)
					{
						return object;
					}
					
					if(object.children)
					{
						for(var num = 0; num < object.children.length; num++)
						{
							var obj = this.getHierarchyObjectByID(object.children[num],id);
							
							if(obj)
							{
								return obj;
							}
						}
					}
				}
				return null;
			},
			
			getHierarchyObjectByName:function(object,name)
			{
				if(object)
				{
					if(object.name == name)
					{
						return object;
					}
					
					if(object.children)
					{
						for(var num = 0; num < object.children.length; num++)
						{
							var obj = this.getHierarchyObjectByName(object.children[num],name);
							
							if(obj)
							{
								return obj;
							}
						}
					}
				}
				return null;
			},
			
			getObjectByPath:function(object,path)
			{
				var arr 	   = path.split("/");
				var tempObject = object;
				
				for(var num = 0; num < arr.length; num++)
				{
					if(tempObject)
					{
						tempObject = this.getHierarchyObjectByName(tempObject,arr[num]);
					}
				}
				return tempObject;
			},
			
			getObjectByIdOrPath:function(object,info)
			{
				if(info)
				{
					if (/[a-zA-Z]/.test(info))
					{
						return this.getObjectByPath(object,info);
					}
					else
					{
						return this.getHierarchyObjectByID(object,info);
					}
				}
				return null;
			},
			
			generateLoziObject:function(data,info,uniqueMaterial)
			{
				if(data)
				{
					
					var obj = data.objects;
					if(info)
					{
						var temp = this.getObjectByIdOrPath(data.objects,info);
						
						if(temp)
						{
							obj = temp;
						}
					}
					
					var type = this.objectByType(obj);
					
					var LoziExtendedObject = LoziObject;
					
					if(type)
					{
						var oldMaterials = [];
						if(uniqueMaterial)
						{
							oldMaterials = data.generatedAssets.materials;
							data.generatedAssets.materials = Lozi.Static.Material.cloneMaterials(oldMaterials)
						}
						
						var child;
						if(obj.type==Lozi.Static.Object.types.Mesh || obj.type==Lozi.Static.Object.types.SkinnedMesh || obj.meshID)
						{
							child = this.generateObject(obj,data.generatedAssets);
							type  = this.classByType(Lozi.Static.Object.types.Object3D);
						}
						
						LoziExtendedObject = this.extend(type,LoziObject);
						var createdObject  = new LoziExtendedObject(data,obj,type,uniqueMaterial);
						
						if(child)
						{
							createdObject.add(child);
						}
						
						if(oldMaterials.length>0)
						{
							data.generatedAssets.materials = oldMaterials;
						}
						
						Lozi.Static.Sound.setSounds(createdObject);
						Lozi.Static.ScriptProperties.parseObjectProperties(createdObject);
						return createdObject;
					}
				}
			},
			
			generateObject:function(obj,data)
			{
				var newObj;
				if(obj.type==Lozi.Static.Object.types.SkinnedMesh || obj.type==Lozi.Static.Object.types.Mesh || obj.meshID)
				{
					newObj = Lozi.Static.Geometry.createMeshByGeometryID(obj.meshID,obj.materials,data);
				}
				if(!newObj)
				{
					var typeObj = this.classByType(obj.type);
					
					if(typeObj && obj.type!=Lozi.Static.Object.types.SkinnedMesh && obj.type!=Lozi.Static.Object.types.Mesh)
					{
						newObj = new typeObj();
					}
				}
				return newObj;
			},
			
			classByType:function(enm)
			{
				return Lozi.Libraries.object().Object.classByType(enm);
			},
			
			objectByType:function(object)
			{
				var type;
				if(object)
				{
					type = Lozi.Static.Object.classByType(object.type);
				}
				return type;
			},
			
			extend:function(baseObj,classObj)
			{
				classObj.prototype = Object.create(baseObj.prototype);
				classObj.prototype.constructor = classObj;

				return classObj;
			},
			
			updateObjectRenderer:function(obj)
			{
				return Lozi.Libraries.object().Object.updateObjectRenderer(obj);
			},
			
			onInteract:function(e,objects,renderer,callback)
			{
				return Lozi.Libraries.object().Object.onInteract(e,objects,renderer,callback);
			},
			
			disposeObject:function(obj)
			{
				Lozi.Libraries.object().Object.disposeObject(obj);
			}
		},
		
	},
	
	Math:
	{
		radians:function(degrees)
		{
		  return degrees * Math.PI / 180;
		},
		 
		degrees:function(radians)
		{
		  return radians * 180 / Math.PI;
		}
	},
	
	disposeData:function(data)
	{
		if(data)
		{
			Lozi.Utils.clearArray (data.generatedAssets.animations.skin,null,100);
			Lozi.Utils.clearArray (data.generatedAssets.materials	   ,Lozi.Static.Material.disposeMaterial,1);
			Lozi.Utils.clearArray (data.generatedAssets.textures	   ,Lozi.Static.Texture.disposeTexture,1);
			Lozi.Utils.clearArray (data.generatedAssets.images		   ,Lozi.Static.Texture.disposeImage,0);
			Lozi.Utils.clearArray (data.generatedAssets.geometries	   ,Lozi.Static.Geometry.disposeGeometry,1000);
			Lozi.Utils.clearArray (data.generatedAssets.sounds	       ,null,1000);
			
			Lozi.Utils.clearArray (data.assets.bones	 ,null,1000);
			Lozi.Utils.clearArray (data.assets.materials ,null,1000);
			Lozi.Utils.clearArray (data.assets.meshes	 ,null,1000);
			Lozi.Utils.clearArray (data.assets.sounds	 ,null,1000);
			Lozi.Utils.clearArray (data.assets.textures  ,null,2);
			Lozi.Utils.clearObject(data.assets.animations,null,1000);
			Lozi.Utils.clearObject(data					 ,null,1000);
		}
	},
	
	loadFromGeneratedData:function(data)
	{
		return Lozi.Static.Object.generateLoziObject(data);
	},
	
	loadFromData:function(data,onComplete,onprogress,error,generateObject)
	{
		generateObject = (generateObject == false) ? generateObject : true;
		
		if(data)
		{	
			var preloadAssets  = function(data,complete,onProgress,error)
			{
				var isLoadComplete = function()
				{
					var completed = true;
					if(data.generatedAssets.images)
					{
						for(var num = 0; num < data.generatedAssets.images.length; num++)
						{
							if(!data.generatedAssets.images[num].loaded)
							{
								completed = false;
							}
						}
					}
					
					if(data.generatedAssets.sounds)
					{
						for(var num = 0; num < data.generatedAssets.sounds.length; num++)
						{
							if(!data.generatedAssets.sounds[num].loaded)
							{
								completed = false;
							}
						}
					}
					
					if(completed == true)
					{
						if(complete)
						{
							complete();
						}
					}
				}
				
				var updateProgress = function()
				{
					var soundProgress = 0;
					var imageProgress = 0;
					var totalProgress = 0;
					var soundCount	  = 0;
					var imageCount 	  = 0;
					
					if(data.generatedAssets.sounds)
					{
						for(var num = 0; num < data.generatedAssets.sounds.length; num++)
						{
							var progress = data.generatedAssets.sounds[num].loadProgress;
							soundProgress += (progress) ? progress : 0;
						}
						soundCount = data.generatedAssets.sounds.length;
						soundProgress = soundProgress/soundCount;
					}
					
					if(data.generatedAssets.images)
					{
						for(var num = 0; num < data.generatedAssets.images.length; num++)
						{
							var progress = data.generatedAssets.images[num].loadProgress;
							imageProgress += (progress) ? progress : 0;
						}
						imageCount = data.generatedAssets.images.length;
						imageProgress = imageProgress/imageCount;
					}
					
					totalProgress = (imageProgress + soundProgress) / 2;
					
					if(soundCount>0)
					{
						totalProgress = soundProgress;
					}
					if(imageCount>0)
					{
						totalProgress = imageProgress;
					}
					if(imageCount>0 && soundCount>0)
					{
						totalProgress = (imageProgress + soundProgress) / 2;
					}
					
					if(onProgress)
					{
						onProgress(totalProgress);
					}
				}
				
				if(data)
				{
					var hasTextures = false;
					var hasSounds   = false;
					data.generatedAssets = (!data.generatedAssets) ? {} : data.generatedAssets;
				
					if(data.assets && data.assets.textures && data.assets.textures.length>0)
					{
						hasTextures = true;
						data.generatedAssets.images = Lozi.Static.Texture.loadImages(data.assets.textures,isLoadComplete,updateProgress,error);
					}
					if(data.assets && data.assets.sounds && data.assets.sounds.length>0)
					{
						hasSounds = true;
						data.generatedAssets.sounds = Lozi.Static.Sound.loadSounds(data.assets.sounds,isLoadComplete,updateProgress,error);
					}
					if(hasTextures == false && hasSounds == false)
					{
						if(complete)
						{
							complete();
						}
					}
				}
			};
			
			var setAssets = function(data)
			{
				if(data.assets && data.assets.textures && data.assets.textures.length>0)
				{
					data.generatedAssets.textures = Lozi.Static.Texture.loadTextures(data.assets.textures);
				}
				if(data.assets && data.assets.meshes &&  data.assets.meshes.length>0)
				{
					data.generatedAssets.geometries = Lozi.Static.Geometry.parseGeometries(data.assets.meshes,data.assets.bones);
				}
				if(data.assets && data.assets.materials && data.assets.materials.length>0)
				{
					data.generatedAssets.materials = Lozi.Static.Material.generateMaterials(data.assets.materials,data);
				}
				if(data.assets && data.assets.animations)
				{
					data.generatedAssets.animations = (!data.generatedAssets.animations) ? {} : data.generatedAssets.animations;
				
					if(data.assets.animations.skin && data.assets.animations.skin.length>0)
					{
						data.generatedAssets.animations.skin = Lozi.Static.Animation.generateSkinAnimations(data.assets.animations.skin,data);
					}
				}
			};
			
			preloadAssets(data,function()
			{
				setAssets(data);
				
				data.createObject = function(info,uniqueMaterials)
				{
					return Lozi.Static.Object.generateLoziObject(data,info,uniqueMaterials);
				};
				
				data.dispose = function()
				{
					Lozi.disposeData(data);
				};
				
				if(onComplete)
				{
					var returnObj  = {};
					returnObj.data = data;
					
					if(generateObject)
					{
						returnObj.object = Lozi.Static.Object.generateLoziObject(data);
					}
					
					onComplete(returnObj);
				}
			},onprogress,error);
		}
	},
	
	loadFromString:function (string,onComplete,onProgress,onError,generateObject)
	{
		return Lozi.loadFromData(JSON.parse(string),onComplete,onProgress,onError,generateObject);
	},

	load:function (url,complete,onProgress,error,generateObject)
	{
		var progress = 
		{
			totalProgress:0,
			assetsProgress:0,
			dataProgress:0
		};
		
		var updateProgress = function(e)
		{
			if(e)
			{
				progress.assetsProgress = e;
			}
			progress.totalProgress = (progress.dataProgress/2)+(progress.assetsProgress/2);
			if(onProgress)
			{
				onProgress(progress);
			}
		}
		
		var xhttp = new XMLHttpRequest();
		xhttp.onload = function(e)
		{
			if (xhttp.readyState == 4 && xhttp.status == 200)
			{
				Lozi.loadFromString(xhttp.responseText,complete,updateProgress,error,generateObject);
			}
			else
			{
				if(error)
				{
					error(xhttp.status);
				}
			}
		}
		
		xhttp.onprogress = function(e)
		{
			if(e.lengthComputable)
			{
				progress.dataProgress  = (e.loaded / e.total);
				updateProgress();
			}
		}
		
		xhttp.open("GET",url, true);
		xhttp.send(null);
	},
	
	version:function()
	{
		return 0.95;
	}
};

var LoziObject = function(data,root,type,hasUniqueMaterials)
{
	var scope      	    = this;
	var deltaTime       = 0;
	var sounds          = [];
	var soundListeners  = [];
	var geometries      = [];
	var materials       = [];
	var uniqueMaterials = [];
	var meshes          = [];
	var blendShapes	    = [];
	var objects         = [];
	var allObjects 	    = [];
	var animations 	    = [];
	var lights     	    = [];
	var cameras    	    = [];
	var properties 	    = [];
	var colliders 	    = [];
	var objectRenderer;
	var onMouseMove;
	var onMouseClick;
	var activeCamera;
	
	if(type)
	{
		type.call(scope);
	}
	
	/* Object Generation Start */

	function createObject(obj,parent)
	{
		if(obj)
		{
			var obj3D = (parent) ? Lozi.Static.Object.generateObject(obj,data.generatedAssets) : scope;
			
			if(obj3D)
			{
				if(obj.id)
				{
					obj3D.loziID = obj.id;
				}
				if(obj.name)
				{
					obj3D.name = obj.name;
				}
				if(obj.meshID)
				{
					obj3D.meshGeometryID = obj.meshID;
				}
				if(obj.animationID)
				{
					obj3D.animationID = obj.animationID;
					animations = animations.concat(Lozi.Static.Animation.setAnimationData(obj3D,data));
				}
				if(obj.lightData)
				{
					Lozi.Static.Light.setLightData(obj3D,obj.lightData);
				}
				if(obj.cameraData)
				{
					Lozi.Static.Camera.setCameraData(obj3D,obj.cameraData);
				}
				if(obj.transform)
				{
					if(obj.transform.position)
					{
						obj3D.position.set(obj.transform.position[0],obj.transform.position[1],obj.transform.position[2]);
					}
					if(obj.transform.rotation)
					{
						if(obj.cameraData)
						{
							obj.transform.rotation[0] = obj.transform.rotation[0] - 180;
							obj3D.rotation.order = "ZYX";
						}
						obj3D.rotation.set(Lozi.Math.radians(obj.transform.rotation[0]),Lozi.Math.radians(obj.transform.rotation[1]),Lozi.Math.radians(obj.transform.rotation[2]));
					}
					if(obj.transform.scale)
					{
						obj3D.scale.set(obj.transform.scale[0],obj.transform.scale[1],obj.transform.scale[2]);
					}
				}
				
				if(obj.scriptProperties)
				{
					obj3D.properties = obj.scriptProperties;
					properties.push(obj3D);
				}
				
				if(obj.collider)
				{
					obj3D.collider = obj.collider;
					colliders.push(obj3D.collider);
				}
				
				if(obj.sound)
				{
					obj3D.sound = obj.sound;
					sounds.push(obj3D);
				}
				
				if(obj3D.geometry)
				{
					obj3D.castShadow    = obj3D.geometry.castShadow;
					obj3D.receiveShadow = obj3D.geometry.receiveShadow;
						
				}
				
				if(obj.children && obj.children.length>0)
				{
					for(var num = 0; num < obj.children.length; num++)
					{
						createObject(obj.children[num],obj3D);
					}
				}
				if(parent)
				{
					parent.add(obj3D);
				}
				objects.push(obj3D);
				
				if(obj.type == Lozi.Static.Object.types.SpotLight 		  ||
				   obj.type == Lozi.Static.Object.types.DirectionalLight ||
				   obj.type == Lozi.Static.Object.types.PointLight 	  ||
				   obj.type == Lozi.Static.Object.types.AreaLight)
				   {
					   lights.push(obj3D);
				   }
				if(obj.type == Lozi.Static.Object.types.OrthographicCamera ||
				   obj.type == Lozi.Static.Object.types.PerspectiveCamera)
				   {
					   cameras.push(obj3D);
				   }
			}
		}
	}

	function createObjectsHierarchy()
	{
		if(root)
		{
			createObject(root,null);
		}
	}
	/* Object Generation End */
	
	function registerObjects(object)
	{
		if(allObjects.indexOf(object)<0)
		{
			allObjects.push(object);
		}
		
		if(object.children)
		{
			for(var num = 0; num < object.children.length; num++)
			{
				registerObjects(object.children[num]);
			}
		}
	}
	
	function assignPropertiesToBones()
	{
		for(var num1 = 0; num1 < objects.length; num1++)
		{
			if(objects[num1].geometry && objects[num1].geometry.bones && objects[num1].skeleton && objects[num1].skeleton.bones)
			{
				for(var num2 = 0; num2 < objects[num1].geometry.bones.length; num2++)
				{
					if(objects[num1].geometry.bones[num2].scriptProperties)
					{
						objects[num1].skeleton.bones[num2].properties = objects[num1].geometry.bones[num2].scriptProperties;
						properties.push(objects[num1].skeleton.bones[num2]);
					}
					if(objects[num1].geometry.bones[num2].collider)
					{
						objects[num1].skeleton.bones[num2].collider = objects[num1].geometry.bones[num2].collider;
						colliders.push(objects[num1].skeleton.bones[num2].collider);
					}
					if(objects[num1].geometry.bones[num2].sound)
					{
						objects[num1].skeleton.bones[num2].sound = objects[num1].geometry.bones[num2].sound;
						sounds.push(objects[num1].skeleton.bones[num2]);
					}
					
					objects[num1].skeleton.bones[num2].loziID = objects[num1].geometry.bones[num2].id;
				}
			}
		}
	}
	
	function addMeshesToArray()
	{
		for(var num = 0; num < objects.length; num++)
		{
			if(objects[num].geometry)
			{
				meshes.push(objects[num]);
				
				if(objects[num].morphTargetInfluences && objects[num].morphTargetInfluences.length>0)
				{
					if(objects[num].geometry.morphTargets)
					{
						var names = [];
						for(var num1 = 0; num1 < objects[num].geometry.morphTargets.length; num1++)
						{
							names.push(objects[num].geometry.morphTargets[num1].name);
						}
					
						blendShapes.push({names:names,influences:objects[num].morphTargetInfluences});
					}
				}
			}
		}
	}
	
	function updateAnimations()
	{
		for(var num = 0; num < animations.length; num++)
		{
			if(animations[num])
			{
				animations[num].update(deltaTime);
			}
		}
	}
	
	function onmousemoveEvent(e)
	{
		if(objectRenderer && onMouseMove)
		{
			Lozi.Static.Object.onInteract(e,objects,objectRenderer,onMouseMove);
		}
	}
	
	function onmouseClickEvent(e)
	{
		if(objectRenderer && onMouseClick)
		{
			Lozi.Static.Object.onInteract(e,objects,objectRenderer,onMouseClick);
		}
	}
	
	function init()
	{
		if(hasUniqueMaterials)
		{
			uniqueMaterials = data.generatedAssets.materials;
		}
		createObjectsHierarchy();
		registerObjects(scope);
		assignPropertiesToBones();
		addMeshesToArray();
	}
	init();

	LoziObject.prototype.update = function(delta)
	{
		deltaTime = delta;
		updateAnimations();
	}
	
	LoziObject.prototype.clone = function(uniqueMaterial)
	{
		var cloned = Lozi.Static.Object.generateLoziObject(this.data(),"",uniqueMaterial);
		
		cloned.position.x = this.position.x;
		cloned.position.y = this.position.y;
		cloned.position.z = this.position.z;
		
		cloned.rotation.x = this.rotation.x;
		cloned.rotation.y = this.rotation.y;
		cloned.rotation.z = this.rotation.z;
			
		cloned.scale.x    = this.scale.x;
		cloned.scale.y    = this.scale.y;
		cloned.scale.z    = this.scale.z;
		
		return cloned;
	}
	
	LoziObject.prototype.delete = function(deleteData)
	{
		deleteData     = (deleteData == true) ? true : false;
		
		this.setOnMouseMove();
		this.setOnMouseClick();
		
		objectRenderer = null;
		activeCamera   = null;
		
		var arr   = [];
		
		arr = Lozi.Utils.getPropertyArray(this.soundSources(),"sound",true);
		Lozi.Utils.clearArray(this.soundSources(),null);
		
		if(uniqueMaterials.length>0)
		{
			Lozi.Utils.clearArray(uniqueMaterials,Lozi.Static.Material.disposeMaterial,1);
		}
		
		Lozi.Utils.clearArray(arr,Lozi.Static.Sound.disposeSoundSource,1,['remove','children']);
		
		Lozi.Utils.clearArray(this.soundListeners(),Lozi.Static.Sound.disposeSoundListener,1,['remove','children']);
		
		Lozi.Utils.clearArray(this.animations(),Lozi.Static.Animation.disposeAnimation,1);
		
		Lozi.Utils.clearArray(this.meshes(),Lozi.Static.Geometry.disposeMesh,1,['remove','children']);
		
		Lozi.Utils.clearArray(this.objects(true),Lozi.Static.Object.disposeObject,1,['update','delete','data','properties','colliders']);
		
		if(deleteData)
		{
			arr = Lozi.Utils.getPropertyArray(this.properties(),"properties",true);
			Lozi.Utils.clearArray(this.properties(),null);
			Lozi.Utils.clearArray(arr,null,3);
			
			arr = Lozi.Utils.getPropertyArray(this.colliders(),"collider",true);
			Lozi.Utils.clearArray(this.colliders(),null);
			Lozi.Utils.clearArray(arr,null,1);
		
			Lozi.disposeData(this.data());
			
			this.data = null;
		}
		arr = null;
	}
	
	LoziObject.prototype.euler = function(x,y,z)
	{
		return Lozi.Utils.eulerAngles(scope,x,y,z);
	}
	
	/* Events Start */
	LoziObject.prototype.setOnMouseMove = function(renderer,callback)
	{
		document.removeEventListener('click',onmousemoveEvent,false);
		onMouseMove = null;
		if(renderer && callback)
		{
			objectRenderer = Lozi.Static.Object.updateObjectRenderer(renderer);
			onMouseMove    = callback;
			
			document.addEventListener('mousemove',onmousemoveEvent,false);
		}
	}
	
	LoziObject.prototype.setOnMouseClick = function(renderer,callback)
	{
		document.removeEventListener('click',onmouseClickEvent,false);
		onMouseClick = null;
		if(renderer && callback)
		{
			objectRenderer = Lozi.Static.Object.updateObjectRenderer(renderer);
			onMouseClick   = callback;
			
			document.addEventListener('click',onmouseClickEvent,false);
		}
	}
	/* Events End */
	
	LoziObject.prototype.activeCamera = function(index)
	{
		if(!activeCamera)
		{
			index = (index) ? index : 0;
			if(cameras && cameras.length>0)
			{
				if(index<cameras.length)
				{
					activeCamera = cameras[index];
				}
			}
		}
		return activeCamera;
	}
	
	LoziObject.prototype.combineMeshes = function()
	{
		meshes = Lozi.Static.Geometry.combineMeshes(this);
	}
	
	LoziObject.prototype.objects = function (getAll)
	{
		if(getAll == true)
		{
			return allObjects;
		}
		return objects;
	}
	
	LoziObject.prototype.getObjectByPath = function (path)
	{
		return Lozi.Static.Object.getObjectByPath(this,this.name+((path.length>0) ? "/"+path : ""));
	}
	
	LoziObject.prototype.meshes  = function ()
	{
		return meshes;
	}
	
	LoziObject.prototype.geometries  = function ()
	{
		return data.generatedAssets.geometries;
	}
	
	LoziObject.prototype.data  = function ()
	{
		return data;
	}
	
	LoziObject.prototype.images  = function ()
	{
		return data.generatedAssets.images;
	}
	
	LoziObject.prototype.textures  = function ()
	{
		return data.generatedAssets.textures;
	}
	
	LoziObject.prototype.materials  = function ()
	{
		if(uniqueMaterials.length>0)
		{
			return uniqueMaterials;
		}
		return data.generatedAssets.materials;
	}
	
	LoziObject.prototype.getMaterialByName = function (name)
	{
		if(name && data.generatedAssets.materials)
		{
			for(var num = 0; num < data.generatedAssets.materials.length; num++)
			{
				if(data.generatedAssets.materials[num].name == name)
				{
					return data.generatedAssets.materials[num];
				}
			}
		}
		return null;
	}
	
	LoziObject.prototype.lights  = function ()
	{
		return lights;
	}
	
	LoziObject.prototype.cameras  = function ()
	{
		return cameras;
	}
	
	LoziObject.prototype.animations  = function ()
	{
		return animations;
	}
	
	/* Properties Start */
	LoziObject.prototype.properties = function ()
	{
		return properties;
	}
	
	LoziObject.prototype.getProperty = function (objectIndex, scriptname, field, returnType)
	{
		if(objectIndex<properties.length)
		{
			if(scriptname)
			{
				if(field)
				{
					if(returnType == true)
					{
						return properties[objectIndex].properties[scriptname][field];
					}
					return properties[objectIndex].properties[scriptname][field].value;
				}
				return properties[objectIndex].properties[scriptname];
			}
			return properties[objectIndex].properties;
		}
	}
	/* Properties End */
	
	/* Colliders Start */
	LoziObject.prototype.colliders = function ()
	{
		return colliders;
	}
	
	LoziObject.prototype.getCollider = function (objectIndex)
	{
		if(objectIndex<colliders.length)
		{
			return colliders[objectIndex];
		}
	}
	/* Colliders End */
	
	/* Sound Start */
	LoziObject.prototype.soundSources = function()
	{
		return sounds;
	}
	
	LoziObject.prototype.soundListeners = function()
	{
		return soundListeners;
	}
	
	LoziObject.prototype.createSoundListener = function(obj)
	{
		var listener = Lozi.Static.Sound.createListener(obj);
		soundListeners.push(listener);
		return listener;
	}
	
	LoziObject.prototype.setSoundListenerVolume = function(index,vol)
	{
		if(soundListeners && index>=0 && index<soundListeners.length)
		{
			vol = (vol<0) ? 0 : (vol>1) ? 1 : vol;
			
			soundListeners[index].setMasterVolume(vol);
			return soundListeners[index].getMasterVolume();
		}
	}
	
	LoziObject.prototype.setSoundSourceSpeed = function(index,rate)
	{
		if(sounds && index>=0 && index<sounds.length)
		{
			if(sounds[index].sound && sounds[index].sound.source)
			{
				rate = (rate<0.1) ? 0.1 : (rate>10) ? 10 : rate;
				
				sounds[index].sound.source.playbackRate.value = rate;
				return sounds[index].sound.source.playbackRate.value;
			}			
		}
	}
	
	LoziObject.prototype.playSoundSource = function(index)
	{
		if(sounds && index>=0 && index<sounds.length)
		{
			if(sounds[index].sound)
			{
				sounds[index].sound.play();
			}			
		}
	}
	
	LoziObject.prototype.pauseSoundSource = function(index)
	{
		if(sounds && index>=0 && index<sounds.length)
		{
			if(sounds[index].sound)
			{
				sounds[index].sound.pause();
			}			
		}
	}
	
	LoziObject.prototype.stopSoundSource = function(index)
	{
		if(sounds && index>=0 && index<sounds.length)
		{
			if(sounds[index].sound)
			{
				sounds[index].sound.stop();
			}			
		}
	}
	
	LoziObject.prototype.setSoundSourceVolume = function(index,vol)
	{
		if(sounds && index>=0 && index<sounds.length)
		{
			if(sounds[index].sound)
			{
				vol = (vol<0) ? 0 : (vol>1) ? 1 : vol;
				
				sounds[index].sound.setVolume(vol);
				return sounds[index].sound.getVolume();
			}			
		}
	}
	
	LoziObject.prototype.createSoundElement = function(name)
	{
		if(data.assets.sounds && data.assets.sounds.length>0)
		{
			for(var num = 0; num < data.assets.sounds.length; num++)
			{
				if(data.assets.sounds[num].name == name)
				{
					var audio = new Audio();
					audio.src = data.assets.sounds[num].data;
					
					return audio;
				}
			}
		}
		return null;
	}
	/* Sound End */
	
	/* BlendShapes Start */
	LoziObject.prototype.blendShapes  = function ()
	{
		return blendShapes;
	}
	
	LoziObject.prototype.setBlendShape = function(index,targetName,target,time)
	{
		time = (!time) ? 0 : time;
		
		if(blendShapes && index>=0 && index<blendShapes.length && (target>=0 || target<=1))
		{
			var shape = blendShapes[index];
			
			if(shape)
			{
				var targetIndex = -1;
				for(var num = 0; num < shape.names.length; num++)
				{
					if(shape.names[num] == targetName)
					{
						targetIndex = num;
						break;
					}
				}
				
				if(targetIndex>=0)
				{
					if(shape.influences[targetIndex]!=target)
					{
						if(time == 0)
						{
							shape.influences[targetIndex] = target;
						}
						else
						{
							var diff      = Math.abs(shape.influences[targetIndex] - target);
							var increment = function()
							{
								var val  = shape.influences[targetIndex];
								var incr = (time*(diff*(deltaTime)))/time;
								if(val!=target)
								{
									val = (val < target) ? Math.min(val+=incr,target) : Math.max(val-=incr,target);
									
									shape.influences[targetIndex]=val;
									
									if(val == target)
									{
										clearInterval(interval);
									}
								}
							};
							interval = setInterval(increment , ((time * 1000) * deltaTime));
						}
					}
				}
			}
		}
	}
	/* BlendShapes End */
	
	/* Animations Start */
	LoziObject.prototype.playAnimation = function(index,clipName,fade,playPrevOnFinish)
	{
		var nextClip = "";
		
		playPrevOnFinish = (playPrevOnFinish==false) ? playPrevOnFinish : true;
		
		fade = (!fade) ? 0 : fade;
		
		if(animations && index>=0 && index<animations.length)
		{
			var from = animations[index].clips[animations[index].currentClip];
			var to   = animations[index].clips[clipName];
			
			if(clipName == animations[index].currentClip && to.mode != "Once")
			{
				return;
			}
			
			if(from)
			{
				from.play();
				from.enabled = true;
				from.clampWhenFinished = true;
				from.setLoop(Lozi.Static.Animation.loopMode(from.mode));
				animations[index].currentClip = from.name;
				
				nextClip = (nextClip) ? nextClip : from.name;
			}
			
			if(to)
			{	
				to.enabled = true;
				to.reset();
				to.play();
				to.setLoop(Lozi.Static.Animation.loopMode(to.mode));
				to.clampWhenFinished = true;
				
				if(to.mode == "Once" && playPrevOnFinish == true && nextClip!=to.name)
				{
					if(nextClip)
					{
						setTimeout(function()
						{
							scope.playAnimation(index,nextClip,fade);
						},(to.duration*1000));
					}
				}
				
				if(from)
				{
					from.crossFadeTo(to,fade);
				}
					
				animations[index].currentClip = to.name;
			}
		}
	}
	
	LoziObject.prototype.stopAnimation = function(index)
	{
		if(animations)
		{
			if(index && index>=0 && index<animations.length)
			{
				if(animations[index].clips)
				{
					animations[index].currentClip = "";
					for(var key in animations[index].clips)
					{
						animations[index].clips[key].stop();
					}
				}
			}
			else
			{
				for(var num = 0; num < animations.length; num++)
				{
					if(animations[num].clips)
					{
						animations[num].currentClip = "";
						for(var key in animations[num].clips)
						{
							animations[num].clips[key].stop();
						}
					}
				}
			}
			
		}
	}
	/* Animations End */
};