/**
 * Created by Beka Mujirishvili
 * 
 * loads, parses and creates objects according to type
 */

var Lozi =
{
	// Libraries Object is for parsing for specific WebGL engine, currently it supports only three.js
	Libraries:
	{
		Three:
		{
			// Geometry Generated by imported data
			Geometry:
			{
				generateGeometry:function(nameData,vertices,normals,uvs,faces)
				{
					var geometry = 
					{
						name	: "",
						vertices: [],
						normals : [],
						uvs     : []
					};
					
					for(var num = 0; num < faces.length; num++ )
					{
						var index  = parseInt(faces[num]);
						var vertex = ((index>=0)?index-1:index+vertices.length/3)*3;
						var normal = ((index>=0)?index-1:index+normals.length/3)*3;
						
						geometry.vertices.push(vertices[vertex],vertices[vertex+1],vertices[vertex+2]);
						geometry.normals .push(normals [normal],normals [normal+1],normals [normal+2]);
					}
					
					for(var num1 = 0; num1 < uvs.length; num1++ )
					{
						geometry.uvs.push([]);
						for(var num2 = 0; num2 < faces.length; num2++ )
						{
							var index  = parseInt(faces[num2]);
							var uv     = ((index>=0)?index-1:index+uvs[num1].length/2)*2;
							geometry.uvs[num1].push(uvs[num1][uv],uvs[num1][uv+1]);
						}
					}
					geometry.name = nameData;
					
					return geometry;
				},
				
				generateSkinData:function(geometry,geomData)
				{
					var influencesPerVertex = 4;
					var weights = [];
					var indices = [];
					
					for(var num = 0; num < geomData.geometry.faces.length; num++ )
					{
						var index  = parseInt(geomData.geometry.faces[num]);
						var weight = ((index>=0)?index-1:index+geomData.skin.skinWeights.length/4)*4;
						var indice = ((index>=0)?index-1:index+indices.length/4)*4;

						weights.push(geomData.skin.skinWeights[weight],geomData.skin.skinWeights[weight+1],geomData.skin.skinWeights[weight+2],geomData.skin.skinWeights[weight+3]);
						indices.push(geomData.skin.skinIndices[indice],geomData.skin.skinIndices[indice+1],geomData.skin.skinIndices[indice+2],geomData.skin.skinIndices[indice+3]);
					}
					
					if (weights && weights.length>0)
					{
						for ( var i = 0, l = weights.length; i < l; i += influencesPerVertex )
						{
							var x =                               	 weights[ i ];
							var y = (weights[ i + 1 ]!==undefined) ? weights[ i + 1 ] : 0;
							var z = (weights[ i + 2 ]!==undefined) ? weights[ i + 2 ] : 0;
							var w = (weights[ i + 3 ]!==undefined) ? weights[ i + 3 ] : 0;

							geometry.skinWeights.push(new THREE.Vector4( x, y, z, w ) );
						}
					}

					if (indices && indices.length>0)
					{
						for ( var i = 0, l = indices.length; i < l; i += influencesPerVertex )
						{
							var a =                               indices[ i ];
							var b = ( influencesPerVertex > 1 ) ? indices[ i + 1 ] : 0;
							var c = ( influencesPerVertex > 2 ) ? indices[ i + 2 ] : 0;
							var d = ( influencesPerVertex > 3 ) ? indices[ i + 3 ] : 0;

							geometry.skinIndices.push(new THREE.Vector4( a, b, c, d ) );
						}
					}
					geometry.bones = geomData.skin.bones;
					return geometry;
				},
			
				generateBlendShapeData:function(geometry,geomzData)
				{
					var morphData = geomzData.morph.blendShapes;
					
					for (var num1 = 0; num1 < morphData.length; num1++)
					{
						geometry.morphTargets[num1]			 = {};
						geometry.morphTargets[num1].name     = morphData[num1].name;
						geometry.morphTargets[num1].vertices = [];
							
						var blendShape   = morphData[num1];
						var geometryData = this.generateGeometry(blendShape.name,blendShape.vertices,geomzData.geometry.normals,geomzData.geometry.uv,geomzData.geometry.faces);
							
						for(var num2 = 0; num2 < geometryData.vertices.length; num2 += 3 )
						{
							var vertex = new THREE.Vector3(geometryData.vertices[num2],geometryData.vertices[num2+1],geometryData.vertices[num2+2]);

							geometry.morphTargets[num1].vertices.push(vertex);
						}
					}
					return geometry;
				},
				
				generateMeshGeometry:function(objInfo)
				{
					var geometry;
					if(objInfo.geometry)
					{
						var geometryData = this.generateGeometry(objInfo.name,
																 objInfo.geometry.vertices,
																 objInfo.geometry.normals,
																 objInfo.geometry.uv,
																 objInfo.geometry.faces);
														
						geometry = new THREE.BufferGeometry();
						geometry.addAttribute('position',new THREE.BufferAttribute(new Float32Array(geometryData.vertices),3));
						
						if(geometryData.normals.length>0){geometry.addAttribute('normal',new THREE.BufferAttribute(new Float32Array(geometryData.normals),3));}
						
						if(geometryData.uvs.length    >0)
						{
							for(var num = 0; num < geometryData.uvs.length; num++)
							{
								var numbr = (num>0) ? num+1 : "";
								geometry.addAttribute('uv'+numbr,new THREE.BufferAttribute(new Float32Array(geometryData.uvs[num]),2));}
							}
					}
					
					geometry.hasSkin  = false;
					geometry.hasMorph = false;
					if(objInfo.skin || objInfo.morph)
					{
						geometry = new THREE.Geometry().fromBufferGeometry(geometry);
						
						if(objInfo.skin)
						{
							geometry.hasSkin = true;
							geometry = this.generateSkinData(geometry,objInfo);
						}
						if(objInfo.morph)
						{
							geometry.hasMorph = true;
							geometry = this.generateBlendShapeData(geometry,objInfo);
						}
					}
					if(objInfo.id)
					{
						geometry.meshID = objInfo.id;
					}
					if(objInfo.geometry.castShadows)
					{
						geometry.castShadow = objInfo.geometry.castShadows;
					}
					if(objInfo.geometry.recieveShadows)
					{
						geometry.receiveShadow = objInfo.geometry.recieveShadows;
					}
					
					return geometry;
				},
				
				createMeshByGeometryID:function(id,matId,data)
				{
					var mesh;
					var material = Lozi.Material.getMaterialByID(matId,data);
					var geometry = Lozi.Geometry.getGeometryByID(id,data);
					
					if(geometry && material)
					{
						if(geometry.hasMorph==false && geometry.hasSkin==false)
						{
							mesh = new THREE.Mesh(geometry,material);
						}
						else
						{
							mesh = new THREE.SkinnedMesh(geometry,material);
							material.skinning 	  = geometry.hasSkin;
							material.morphTargets = geometry.hasMorph;
						}
						if(geometry.recieveShadows)
						{
							mesh.receiveShadow = geometry.receiveShadow;
						}
						if(geometry.castShadows)
						{
							mesh.castShadow    = geometry.castShadow;
						}
					}
					return mesh;
				}
			},
			
			Material:
			{
				generateMaterial:function(matData,data)
				{
					var material;
					
					switch(matData.type)
					{
						case 0:{material = new THREE.MeshStandardMaterial(); break;}
						case 1:{material = new THREE.MeshBasicMaterial   (); break;}
						case 2:{material = new THREE.MeshPhongMaterial   (); break;}
						case 3:{material = new THREE.MeshLambertMaterial (); break;}
					}
					if(material)
					{
						material.matId = matData.id;
						material.name  = matData.name;
						
						if(matData.properties)
						{
								
							if(matData.properties._Color)
							{
								material.color = new THREE.Color(matData.properties._Color[0],matData.properties._Color[1],matData.properties._Color[2]);
							}
							if(matData.properties._Metallic)
							{
								material.metalness = matData.properties._Metallic;
							}
							if(matData.properties._EmissionColor)
							{
								material.emissive = new THREE.Color(matData.properties._EmissionColor[0],matData.properties._EmissionColor[1],matData.properties._EmissionColor[2]);
							}
							if(matData.properties._MainTex)
							{
								material.map      = Lozi.Texture.getTextureByID(matData.properties._MainTex,data);
							}
							if(matData.properties._BumpMap)
							{
								material.bumpMap      = Lozi.Texture.getTextureByID(matData.properties._BumpMap,data);
								material.bumpMapScale = 1;
							}
							if(matData.properties._BumpScale)
							{
								material.bumpMapScale = matData.properties._BumpScale;
							}
							if(matData.properties._Cube)
							{
								material.envMap = Lozi.Texture.getTextureByID(matData.properties._Cube,data);
							}
							if(matData.properties._ReflectColor)
							{
								material.envMapIntensity = matData.properties._ReflectColor[3];
							}
							if(matData.properties.transparentMap)
							{
								material.transparent = true;
								material.alphaMap = Lozi.Texture.getTextureByID(matData.properties.transparentMap,data);
							}
							if(matData.properties.lightMap)
							{
								material.lightMap = Lozi.Texture.getTextureByID(matData.properties.lightMap,data);
								material.emissiveMap = material.lightMap;
							}
						}
						return material;
					}
				}
			},
			
			Texture:
			{
				generateTexture:function(dataObj)
				{
					if(dataObj && dataObj.textureData && dataObj.textureData.length>0)
					{
						if(dataObj.textureData[0])
						{
							var image     	     = Lozi.Texture.loadImage(dataObj.textureData[0]);
							var texture   	     = new THREE.Texture();
							texture.texID	     = dataObj.id;
							texture.name  	     = dataObj.name;
							texture.image 	     = image;
							texture.usedImages   = [texture.image];
							texture.image.onload = function()
							{
								texture.needsUpdate = true;
							}
							return texture;
						}
					}
				},
				
				generateCubeTexture:function(dataObj)
				{
					if(dataObj && dataObj.textureData && dataObj.textureData.length>0)
					{
						var texture    	   = new THREE.CubeTexture();
						texture.texID  	   = dataObj.id;
						texture.name   	   = dataObj.name;
						texture.images 	   = [];
						texture.usedImages = texture.images;
						
						for(var num = 0; num < dataObj.textureData.length; num++)
						{
							texture.images.push(Lozi.Texture.loadImage(dataObj.textureData[num]));
							texture.images[num].onload = function(num)
							{
								texture.needsUpdate = true;
							}
						}
						return texture;
					}
				}
			},
			
			Animation:
			{
				generateSkinAnimationClip:function(clip,target,objects)
				{
					if(clip && target && objects)
					{
						if(objects && objects.length>0)
						{
							if(clip.hierarchy)
							{
								var nodes = [];
								for ( var num = 0; num < objects.length; num++ )
								{
									nodes.push({});
								}
								
								for ( var num1 = 0; num1 < clip.hierarchy.length; num1++ )
								{
									var hier = clip.hierarchy[num1];
									if(hier.keys)
									{
										for ( var num2 = 0; num2 < hier.keys.length; num2++ )
										{
											hier.keys[num2] = hier.keys[num2];
										}
									}
									nodes[clip.hierarchy[num1].index] = hier;
								}
							}
							clip.hierarchy = nodes;
							
							var generatedClip = THREE.AnimationClip.parseAnimation(clip,objects);
							
							if (generatedClip)
							{
								if(!target.animations)
								{
									target.animations = [];
								}
								target.animations.push(generatedClip);
								
								return generatedClip;
							}
						}
					}
				},
			},
			
			Light:
			{
				setLightData:function(targetLight,data)
				{
					targetLight.color 	   = new THREE.Color(data.color[0],data.color[1],data.color[2]);
					targetLight.intensity  = data.intensity;
					targetLight.distance   = data.range;
					targetLight.angle      = Lozi.Math.radians(data.angle);
					targetLight.castShadow = data.shadow;
				}
			},
			
			Camera:
			{
				setCameraData:function(targetCamera,data)
				{
					targetCamera.fov    =-data.fov;
					targetCamera.near   = data.near;
					targetCamera.far    = data.far;
					targetCamera.left   = data.orthoSize;
					targetCamera.right  = data.orthoSize;
					targetCamera.top    = data.orthoSize;
					targetCamera.bottom = data.orthoSize;
					targetCamera.updateProjectionMatrix();
				}
			},
			
			Object:
			{
				// Object created by given type
				classByType:function(enm)
				{
					switch(enm)
					{
						case Lozi.Object.types.Mesh				 :{type = THREE.Mesh; 		  	    break;}
						case Lozi.Object.types.SkinnedMesh		 :{type = THREE.SkinnedMesh; 		break;}
						//case Lozi.Object.types.OrthographicCamera:{type = THREE.OrthographicCamera; break;}
						case Lozi.Object.types.OrthographicCamera:{type = THREE.PerspectiveCamera;  break;}
						case Lozi.Object.types.PerspectiveCamera :{type = THREE.PerspectiveCamera;  break;}
						case Lozi.Object.types.AreaLight		 :{type = THREE.AmbientLight;    	break;}
						case Lozi.Object.types.PointLight		 :{type = THREE.PointLight;    	    break;}
						case Lozi.Object.types.DirectionalLight  :{type = THREE.DirectionalLight;   break;}
						case Lozi.Object.types.SpotLight		 :{type = THREE.SpotLight;    	    break;}
						case Lozi.Object.types.Object			 :
						case Lozi.Object.types.AnimationObject	 :
						case Lozi.Object.types.Object3D			 :{type = THREE.Object3D;    		break;}
						case Lozi.Object.types.Scene			 :{type = THREE.Scene;    	  	    break;}
					}
					return type;
				}
			}
		}
	},
	
	Geometry:
	{
		generateMeshGeometry:function(objInfo)
		{
			return Lozi.libraryObject().Geometry.generateMeshGeometry(objInfo);
		},
		
		parseGeometries:function(meshes)
		{
			var geometries = [];
			if(meshes)
			{
				for(var num = 0; num < meshes.length; num++)
				{
					if(meshes[num])
					{
						geometries.push(this.generateMeshGeometry(meshes[num]));
					}
				}
			}
			return geometries;
		},
		
		getGeometryByID:function(id,data)
		{
			if(data.generatedAssets.geometries && data.generatedAssets.geometries.length>0)
			{
				for(var num = 0; num < data.generatedAssets.geometries.length; num++)
				{
					if(data.generatedAssets.geometries[num].meshID == id)
					{
						return data.generatedAssets.geometries[num];
					}
				}
			}
			return null;
		},
		
		createMeshByGeometryID:function(id,materialId,data)
		{
			return Lozi.libraryObject().Geometry.createMeshByGeometryID(id,materialId,data);
		}
	},
	
	Material:
	{
		generateMaterial:function(matData,textures)
		{
			return Lozi.libraryObject().Material.generateMaterial(matData,textures);
		},
		
		generateMaterials:function(materialData,data)
		{
			var materials = [];
			for(var num = 0; num < materialData.length; num++)
			{
				var material = this.generateMaterial(materialData[num],data);
				if(material)
				{
					materials.push(material);
				}
			}
			return materials;
		},
		
		getMaterialByID:function(id,data)
		{
			if(data.generatedAssets && data.generatedAssets.materials)
			{
				for(var num = 0; num < data.generatedAssets.materials.length; num++)
				{
					if(data.generatedAssets.materials[num].matId == id)
					{
						return data.generatedAssets.materials[num];
					}
				}
			}
		}
	},
	
	Texture:
	{
		loadImage:function(imageData)
		{
			if(!Image.onProgress)
			{	
				Image.prototype.onProgress = function(){}
				
				Image.prototype.onLoaded   = function(){}
				
				Image.prototype.check      = function()
				{
					if(this.isBase64)
					{
						if(this.onProgress)
						{
							this.onProgress(this);
						}
						if(this.onLoaded)
						{
							this.onLoaded();
						}
					}
				}
				
				Image.prototype.load = function(url)
				{
					var img      = this;
					var xmlHTTP  = new XMLHttpRequest();
					img.isBase64 = false;
					
					xmlHTTP.onload = function( e )
					{
						var blob = new Blob( [ this.response ]);
						img.src  = window.URL.createObjectURL( blob );
						if(img.onLoaded)
						{
							img.onLoaded();
						}
					};

					xmlHTTP.onprogress = function( e )
					{
						img.completedPercentage = ( e.loaded / e.total );
						if(img.completedPercentage<0)
						{
							img.completedPercentage = 1;
						}
						if(img.onProgress)
						{
							img.onProgress(img);
						}
					};

					xmlHTTP.onloadstart = function()
					{
						img.completedPercentage = 0;
					};
					
					if(url.indexOf("data:image/png;base64,")>-1)
					{
						img.src 				= url;
						img.completedPercentage = 1;
						img.isBase64            = true;
					}
					else
					{
						xmlHTTP.open('GET', url , true );
						xmlHTTP.responseType = 'arraybuffer';
						xmlHTTP.send();
					}
				}
			}
			var image = new Image();
			image.load(imageData);
			
			return image;
		},
		
		loadTexture:function(texData)
		{
			if(texData && texData.textureData && texData.textureData.length>0)
			{
				var texture;
				switch(texData.textureData.length)
				{
					case 1:{texture = Lozi.libraryObject().Texture.generateTexture	  (texData); break;}
					case 6:{texture = Lozi.libraryObject().Texture.generateCubeTexture(texData); break;}
				}
				return texture;
			}
		},
		
		loadTextures:function(texturesData,progress,complete)
		{
			var textures = [];
			
			for(var num = 0; num < texturesData.length; num++)
			{
				var texture = this.loadTexture(texturesData[num]);
				if(texture)
				{
					textures.push(texture);
				}
			}
			return textures;
		},
		
		getTextureImages:function(textures,progress,complete)
		{
			var images = [];
			for(var num1 = 0; num1 < textures.length; num1++)
			{
				for(var num2 = 0; num2 < textures[num1].usedImages.length; num2++)
				{
					textures[num1].usedImages[num2].onLoaded   = complete;
					textures[num1].usedImages[num2].onProgress = progress;
					images.push(textures[num1].usedImages[num2]);
				}
			}
			return images;
		},
		
		getTextureByID:function(id,data)
		{
			if(data.generatedAssets && data.generatedAssets.textures)
			{
				for(var num = 0; num < data.generatedAssets.textures.length; num++)
				{
					if(data.generatedAssets.textures[num].texID == id)
					{
						return data.generatedAssets.textures[num];
					}
				}
			}
		}
	},
	
	Animation:
	{
		generateSkinAnimationClip:function(clip,target,objects)
		{
			return Lozi.libraryObject().Animation.generateSkinAnimationClip(clip,target,objects);
		},
	},
	
	Light:
	{
		setLightData:function(target,data)
		{
			Lozi.libraryObject().Light.setLightData(target,data);
		}
	},
	
	Camera:
	{
		setCameraData:function(target,data)
		{
			Lozi.libraryObject().Camera.setCameraData(target,data);
		}
	},
	
	Object:
	{
		types:
		{
			None               : 0,
			Scene    		   : 1,
			Object3D 		   : 2,
			AnimationObject    : 3,
			Object			   : 4,
			Bone               : 5,
			SpotLight   	   : 6,
			DirectionalLight   : 7,
			PointLight 		   : 8,
			AreaLight 		   : 9,
			PerspectiveCamera  : 10,
			OrthographicCamera : 11,
			SkinnedMesh 	   : 12,
			Mesh 			   : 13
		},
		
		getObjectByProperty:function(objects,prop,val)
		{
			if(objects && objects.length>0)
			{
				for(var num = 0; num < objects.length; num++)
				{
					if(objects[num][prop] && objects[num][prop] == val)
					{
						return objects[num];
					}
				}
			}
			return null;
		},
		
		generateLoziObject:function(data)
		{
			var type = this.objectByType(data);
			var LoziExtendedObject = LoziObject;
			
			if(type)
			{
				var child;
				if(data.objects.type==Lozi.Object.types.Mesh || data.objects.type==Lozi.Object.types.SkinnedMesh || data.objects.meshID)
				{
					child = this.generateObject(data.objects,data);
					type  = this.classByType(Lozi.Object.types.Object3D);
				}
				
				LoziExtendedObject = this.extend(type,LoziObject);
				var createdObject  = new LoziExtendedObject(data,type);
				
				if(child)
				{
					createdObject.add(child);
				}
				
				setTimeout(function()
				{
					if(data.objects.flip)
					{
						createdObject.flip((data.objects.flip[0] && data.objects.flip[0]<0) ? true : false,
										   (data.objects.flip[1] && data.objects.flip[1]<0) ? true : false,
										   (data.objects.flip[2] && data.objects.flip[2]<0) ? true : false);
					}
				},10);
				
				
				return createdObject;
			}
		},
		
		generateObject:function(obj,data)
		{
			var newObj;
			if(obj.type==Lozi.Object.types.SkinnedMesh || obj.type==Lozi.Object.types.Mesh || obj.meshID)
			{
				newObj = Lozi.Geometry.createMeshByGeometryID(obj.meshID,obj.materialID,data);
			}
			if(!newObj)
			{
				var typeObj = this.classByType(obj.type);
				
				if(typeObj && obj.type!=Lozi.Object.types.SkinnedMesh && obj.type!=Lozi.Object.types.Mesh)
				{
					newObj = new typeObj();
				}
			}
			return newObj;
		},
		
		classByType:function(enm)
		{
			return Lozi.libraryObject().Object.classByType(enm);
		},
		
		objectByType:function(data)
		{
			var type;
			if(data)
			{
				if(data.objects)
				{
					type = Lozi.Object.classByType(data.objects.type);
				}
			}
			return type;
		},
		
		extend:function(baseObj,classObj)
		{
			classObj.prototype = Object.create(baseObj.prototype);
			classObj.prototype.constructor = classObj;

			return classObj;
		}
	},
	
	libraryObject:function()
	{
		if(THREE)
		{
			return Lozi.Libraries.Three;
		}
		console.error("NO WEBGL LIBRARY INCLUDED!");
	},
		
	Math:
	{
		radians:function(degrees)
		{
		  return degrees * Math.PI / 180;
		},
		 
		degrees:function(radians)
		{
		  return radians * 180 / Math.PI;
		}
	},
	
	loadFromData:function(data,onProgress,onComplete)
	{
		if(data)
		{
			var updateProgress = function(e)
			{
				if(data.generatedAssets.images)
				{
					var progress = 0;
					
					for(var num = 0; num < data.generatedAssets.images.length; num++)
					{
						progress+=data.generatedAssets.images[num].completedPercentage;
					}
					
					if(onProgress)
					{
						onProgress(progress/data.generatedAssets.images.length);
					}
				}
			}
			
			var onCompleted = function(e)
			{
				var completed = true;
				for(var num = 0; num < data.generatedAssets.images.length; num++)
				{
					if(data.generatedAssets.images[num].completedPercentage<1)
					{
						completed = false;
					}
				}
				
				if(completed==true)
				{
					if(onComplete)
					{
						onComplete({data:data,object:Lozi.Object.generateLoziObject(data)});
					}
				}
			}
			
			data.generatedAssets = (!data.generatedAssets) ? {} : data.generatedAssets;
			
			if(data.assets && data.assets.meshes &&  data.assets.meshes.length>0)
			{
				data.generatedAssets.geometries = Lozi.Geometry.parseGeometries(data.assets.meshes);
			}
			if(data.assets && data.assets.textures && data.assets.textures.length>0)
			{
				data.generatedAssets.textures = Lozi.Texture.loadTextures(data.assets.textures);
				data.generatedAssets.images   = Lozi.Texture.getTextureImages(data.generatedAssets.textures,updateProgress,onCompleted);
			}
			if(data.assets && data.assets.materials && data.assets.materials.length>0)
			{
				data.generatedAssets.materials = Lozi.Material.generateMaterials(data.assets.materials,data);
			}
			
			
			if(data.generatedAssets.images)
			{
				for(var num = 0; num < data.generatedAssets.images.length; num++)
				{
					data.generatedAssets.images[num].check();
				}
			}
			if(!data.generatedAssets.images || (data.generatedAssets.images && data.generatedAssets.images.length==0))
			{
				if(onProgress)
				{
					onProgress(1);
				}
				if(onComplete)
				{
					onComplete({data:data,object:Lozi.Object.generateLoziObject(data)});
				}
			}
		}
	},
	
	loadFromString:function (string,onProgress,onComplete)
	{
		return Lozi.loadFromData(JSON.parse(string),onProgress,onComplete);
	},

	load:function (url,complete,onProgress,error)
	{
		var progress = 
		{
			totalProgress:0,
			dataProgress:0,
			textureProgress:0
		};
		
		var updateProgress = function()
		{
			progress.totalProgress = (progress.dataProgress/2)+(progress.textureProgress/2);
			if(onProgress)
			{
				onProgress(progress);
			}
		}
		
		var xhttp = new XMLHttpRequest();
		xhttp.onload = function(e)
		{
			if (xhttp.readyState == 4 && xhttp.status == 200)
			{
				Lozi.loadFromString(xhttp.responseText,
				function(e)
				{
					progress.textureProgress = e;
					updateProgress();
				},
				complete);
			}
			else
			{
				if(error)
				{
					error(xhttp.status);
				}
			}
		}
		
		xhttp.onprogress = function(e)
		{
			if(e.lengthComputable)
			{
				progress.dataProgress  = (e.loaded / e.total);
				updateProgress();
			}
		}
		
		xhttp.open("GET",url, true);
		xhttp.send(null);
	}
};

var LoziObject = function(data,type)
{
	var scope      = this;
	var objects    = [];
	var animations = [];
	var lights     = [];
	var cameras    = [];
	var activeCamera;
	
	if(type)
	{
		type.call(scope);
	}

	/* Animations Start */
	
	function generateSkinAnimation(obj,animation)
	{
		if(animation && obj)
		{
			if(obj.meshGeometryID)
			{
				var geom = Lozi.Object.getObjectByProperty(data.assets.meshes,'id',obj.meshGeometryID);
				
				if(animation.clips && animation.clips.length>0 && geom.skin && geom.skin.bones && geom.skin.bones.length>0)
				{
					var mixer = new THREE.AnimationMixer(obj);
					for(var num = 0; num < animation.clips.length; num++)
					{
						if(animation.clips[num])
						{
							var clip  = Lozi.Animation.generateSkinAnimationClip(animation.clips[num],obj,geom.skin.bones);
							
							mixer.clipAction(clip, obj);
						}
					}
					obj.mixer = mixer;
					animations.push(mixer);
				}
			}
		}
	}
	
	function generateSkinAnimations()
	{
		if(data.assets.animations && data.assets.animations.skin && data.assets.animations.skin.length>0 && objects)
		{
			for(var num = 0; num < objects.length; num++)
			{
				if(objects[num].animationID)
				{
					var animation = Lozi.Object.getObjectByProperty(data.assets.animations.skin,'id',objects[num].animationID);
					
					if(animation)
					{
						generateSkinAnimation(objects[num],animation);
					}
				}
			}
		}
	}
	/* Animations End */
	
	/* Object Generation Start */

	function createObject(obj,parent)
	{
		if(obj)
		{
			var obj3D = (parent) ? Lozi.Object.generateObject(obj,data) : scope;
			
			if(obj3D)
			{
				if(obj.id)
				{
					obj3D.loziID = obj.id;
				}
				if(obj.name)
				{
					obj3D.name = obj.name;
				}
				if(obj.meshID)
				{
					obj3D.meshGeometryID = obj.meshID;
				}
				if(obj.animationID)
				{
					obj3D.animationID = obj.animationID;
				}
				if(obj.lightData)
				{
					Lozi.Light.setLightData(obj3D,obj.lightData);
				}
				if(obj.cameraData)
				{
					Lozi.Camera.setCameraData(obj3D,obj.cameraData);
				}
				if(obj.transform)
				{
					if(obj.transform.position)
					{
						obj3D.position.order = "ZYX";
						obj3D.position.set(obj.transform.position[0],obj.transform.position[1],obj.transform.position[2]);
					}
					if(obj.transform.rotation)
					{
						if(obj.cameraData)
						{
							obj.transform.rotation[0] = obj.transform.rotation[0] - 180;
						}
						obj3D.rotation.order = "ZYX";
						obj3D.rotation.set(Lozi.Math.radians(obj.transform.rotation[0]),Lozi.Math.radians(obj.transform.rotation[1]),Lozi.Math.radians(obj.transform.rotation[2]));
					}
						
					if(obj.transform.scale)
					{
						obj3D.scale.set(obj.transform.scale[0],obj.transform.scale[1],obj.transform.scale[2]);
					}
				}
				
				if(obj3D.geometry)
				{
					obj3D.castShadow    = obj3D.geometry.castShadow;
					obj3D.receiveShadow = obj3D.geometry.receiveShadow;
						
				}
				
				if(obj.children && obj.children.length>0)
				{
					for(var num = 0; num < obj.children.length; num++)
					{
						createObject(obj.children[num],obj3D);
					}
				}
				if(parent)
				{
					parent.add(obj3D);
				}
				objects.push(obj3D);
				
				if(obj.type == Lozi.Object.types.SpotLight 		  ||
				   obj.type == Lozi.Object.types.DirectionalLight ||
				   obj.type == Lozi.Object.types.PointLight 	  ||
				   obj.type == Lozi.Object.types.AreaLight)
				   {
					   lights.push(obj3D);
				   }
				if(obj.type == Lozi.Object.types.OrthographicCamera ||
				   obj.type == Lozi.Object.types.PerspectiveCamera)
				   {
					   cameras.push(obj3D);
				   }
			}
		}
	}

	function createObjectsHierarchy()
	{
		if(data && data.objects)
		{
			createObject(data.objects,null);
		}
	}
	/* Object Generation End */
	
	function init()
	{
		createObjectsHierarchy();
		generateSkinAnimations();
	}
	init();

	LoziObject.prototype.setActiveCamera = function(index)
	{
		if(cameras)
		{
			if(index<cameras.length)
			{
				activeCamera = cameras[index];
			}
		}
	}
	
	LoziObject.prototype.activeCamera = function(index)
	{
		if(!activeCamera)
		{
			if(cameras && cameras.length>0)
			{
				activeCamera = cameras[0];
			}
		}
		return activeCamera;
	}
	
	LoziObject.prototype.flip = function(flipX,flipY,flipZ)
	{
		flipX = (flipX) ? flipX : false;
		flipY = (flipY) ? flipY : false;
		flipZ = (flipZ) ? flipZ : false;
		
		if(data.generatedAssets && data.generatedAssets.materials)
		{
			for(var num = 0; num < data.generatedAssets.materials.length; num++)
			{
				data.generatedAssets.materials[num].side = THREE.FrontSide;
			}
		}
		
		if(flipX == true)
		{
			scope.scale.x = -scope.scale.x;
			for(var num = 0; num < cameras.length; num++)
			{
				cameras[num].scale.x = -cameras[num].scale.x;
			}
		}
		
		if(flipY == true)
		{
			scope.scale.y = -scope.scale.y;
			for(var num = 0; num < cameras.length; num++)
			{
				cameras[num].scale.y = -cameras[num].scale.y;
			}
		}
		
		if(flipZ == true)
		{
			scope.scale.z = -scope.scale.z;
			for(var num = 0; num < cameras.length; num++)
			{
				cameras[num].scale.z = -cameras[num].scale.z;
			}
		}
		
		if(flipX == true || flipY == true || flipZ == true)
		{
			if(data.generatedAssets && data.generatedAssets.materials)
			{
				for(var num = 0; num < data.generatedAssets.materials.length; num++)
				{
					data.generatedAssets.materials[num].side = THREE.BackSide;
				}
			}
		}
	}
	
	LoziObject.prototype.setScale = function(scaleX,scaleY,scaleZ)
	{
		if(scaleX)
		{
			scope.scale.x = (scope.scale.x<0) ? -scaleX : scaleX;
		}
		if(scaleY)
		{
			scope.scale.y = (scope.scale.y<0) ? -scaleY : scaleY;
		}
		if(scaleZ)
		{
			scope.scale.z = (scope.scale.z<0) ? -scaleZ : scaleZ;
		}
	}
	
	LoziObject.prototype.updateAnimations = function(delta)
	{
		for(var num = 0; num < animations.length; num++)
		{
			animations[num].update(delta);
		}
	}

	LoziObject.prototype.euler = function(x,y,z)
	{
		scope.rotation.set(Lozi.Math.radians(x),Lozi.Math.radians(y),Lozi.Math.radians(z));
	}

	LoziObject.prototype.objects = function ()
	{
		return objects;
	}
	
	LoziObject.prototype.geometries  = function ()
	{
		return data.generatedAssets.geometries;
	}
	
	LoziObject.prototype.data  = function ()
	{
		return data;
	}
	
	LoziObject.prototype.images  = function ()
	{
		return data.generatedAssets.images;
	}
	
	LoziObject.prototype.textures  = function ()
	{
		return data.generatedAssets.textures;
	}
	
	LoziObject.prototype.materials  = function ()
	{
		return data.generatedAssets.materials;
	}
	
	LoziObject.prototype.lights  = function ()
	{
		return lights;
	}
	
	LoziObject.prototype.cameras  = function ()
	{
		return cameras;
	}
	
	LoziObject.prototype.animations  = function ()
	{
		return animations;
	}
	
	LoziObject.prototype.geometryByID  = function (id)
	{
		return Lozi.Geometry.getGeometryByID(id,data);
	}
};